/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import t from"../core/Error.js";import r from"../core/Loadable.js";import{L as s}from"../chunks/Logger.js";import{EsriPromiseMixin as n}from"../core/Promise.js";import{whenOrAbort as o,throwIfAborted as i,allSettledValues as a,isAborted as c,createAbortError as l}from"../core/promiseUtils.js";import{on as p,watch as u}from"../core/reactiveUtils.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"../chunks/ensureType.js";import"../chunks/typedArrayUtil.js";import{subclass as f}from"../core/accessorSupport/decorators/subclass.js";import{c as h,Z as g}from"../chunks/vec3f64.js";import d from"./Extent.js";import x from"./Geometry.js";import y from"./Point.js";import w from"./Polygon.js";import{c as j,a as v,b as k,d as b,e as A}from"../chunks/axisAngleDegrees.js";import S,{M as R}from"./support/MeshComponent.js";import{M as F,C as M,I as L,a as U,N as P,b as O,c as C}from"../chunks/meshErrors.js";import z from"./support/MeshGeoreferencedRelativeVertexSpace.js";import E from"./support/MeshGeoreferencedVertexSpace.js";import T from"./support/MeshLocalVertexSpace.js";import _ from"./support/MeshTransform.js";import{t as D}from"../chunks/triangulationUtils.js";import{p as $,v as B,i as G,u as I,g as V,a as W,b as N,c as q,d as H,e as Z,f as J,h as K}from"../chunks/georeference.js";import{b as Q,d as X,r as Y,p as ee,s as te,t as re,q as se}from"../chunks/vec3.js";import{p as ne}from"../chunks/projectPointToVector.js";import"../chunks/assets.js";import"../request.js";import{removeFile as oe,makeRelative as ie}from"../core/urlUtils.js";import"../chunks/basicInterfaces.js";import{Clonable as ae}from"../core/Clonable.js";import ce from"../core/Collection.js";import{i as le,e as pe,a as ue}from"../chunks/External.js";import{f as me}from"../chunks/mat3.js";import{a as fe}from"../chunks/mat3f64.js";import{a as he}from"../chunks/mat4f64.js";import{g as ge}from"../chunks/spatialReferenceEllipsoidUtils.js";import{c as de}from"../chunks/computeTranslationToOriginAndRotation.js";import{f as xe}from"../chunks/mat4.js";import{i as ye,a as we}from"../chunks/infoFor3D.js";import"../core/lang.js";import"../config.js";import"../chunks/maybe.js";import"../core/Accessor.js";import"../core/Handles.js";import"../chunks/metadata.js";import"../chunks/utils.js";import"../chunks/handleUtils.js";import"../chunks/ObjectPool.js";import"../chunks/ObservableBase.js";import"../chunks/tracking.js";import"../core/scheduling.js";import"../chunks/nextTick.js";import"../chunks/PooledArray.js";import"../chunks/time.js";import"../chunks/asyncUtils.js";import"../core/Evented.js";import"../chunks/shared.js";import"../chunks/SimpleObservable.js";import"./SpatialReference.js";import"../core/JSONSupport.js";import"../chunks/unitUtils.js";import"../chunks/jsonMap.js";import"../chunks/Ellipsoid.js";import"../chunks/writer.js";import"../kernel.js";import"./support/webMercatorUtils.js";import"../chunks/reader.js";import"../core/accessorSupport/decorators/cast.js";import"../chunks/Axis.js";import"../chunks/extentUtils.js";import"../chunks/aaBoundingRect.js";import"../chunks/mathUtils.js";import"../chunks/zmUtils.js";import"../chunks/common.js";import"../chunks/quat.js";import"../chunks/vec4.js";import"../chunks/quatf64.js";import"./support/MeshMaterial.js";import"../Color.js";import"../chunks/colorUtils.js";import"./support/MeshTexture.js";import"../chunks/imageUtils.js";import"../chunks/persistableUrlUtils.js";import"./support/MeshTextureTransform.js";import"./support/MeshMaterialMetallicRoughness.js";import"../chunks/enumeration.js";import"../chunks/earcut.js";import"../chunks/_commonjsHelpers.js";import"../chunks/DoubleArray.js";import"../chunks/Indices.js";import"../chunks/deduplicate.js";import"../geometry.js";import"./Multipoint.js";import"./Polyline.js";import"../chunks/typeUtils.js";import"./support/jsonUtils.js";import"../chunks/plane.js";import"../chunks/vector.js";import"../chunks/ByteSizeUnit.js";import"../chunks/vec2f64.js";import"../chunks/vec4f64.js";import"../chunks/mathUtils2.js";import"../chunks/Attribute.js";import"../chunks/ContentObject.js";import"../chunks/Geometry.js";import"../chunks/Util.js";import"../chunks/triangle.js";import"../chunks/lineSegment.js";import"../chunks/VertexAttribute.js";import"../chunks/doublePrecisionUtils.js";import"./projection.js";import"../chunks/projectBuffer.js";import"../chunks/geodesicConstants.js";import"./support/GeographicTransformation.js";import"./support/GeographicTransformationStep.js";import"../chunks/zscale.js";import"../chunks/vec32.js";import"../chunks/BufferView.js";import"../chunks/vec2.js";let je=null;function ve(e,t){let r=1/0,s=1/0,n=1/0,o=-1/0,i=-1/0,a=-1/0;const c=e.length;let l=0;for(;l<c;){const t=e[l++],c=e[l++],p=e[l++];r=Math.min(r,t),s=Math.min(s,c),n=Math.min(n,p),o=Math.max(o,t),i=Math.max(i,c),a=Math.max(a,p)}return new d({xmin:r,ymin:s,zmin:n,xmax:o,ymax:i,zmax:a,spatialReference:t})}const ke="esri.geometry.support.meshUtils.centerAt",be=h(),Ae=h(),Se=h();function Re(e){const t=oe(e.url);return r=>{const s=ie(r,t,t),n=s?s.replace(/^ *\.\//,""):null;return(n?e.files.get(n):null)??r}}function Fe(e){return Ce.fromBlob(e,ze(e.name,e.type))}const Me=/^model\/gltf\+json$/,Le=/^model\/gltf-binary$/,Ue=/\.gltf$/i,Pe=/\.glb$/i;function Oe(e){const r=new Map;let s,n=null;for(const{name:t,mimeType:o,source:i}of e)null===n&&(Me.test(o)||Ue.test(t)?(n=i.url,s="gltf"):(Le.test(o)||Pe.test(t))&&(n=i.url,s="glb")),r.set(t,i.url),i.files.forEach(((e,t)=>r.set(t,e)));if(null==n)throw new t("mesh-load-external:missing-files","Missing files to load external mesh source");return new Ce(n,(()=>e.forEach((({source:e})=>e.dispose()))),r,s)}class Ce{constructor(e,t=(()=>{}),r=new Map,s){this.url=e,this.dispose=t,this.files=r,this.type=s}static fromBlob(e,t){const r=URL.createObjectURL(e);return new Ce(r,(()=>URL.revokeObjectURL(r)),void 0,t)}}function ze(e,t){return Me.test(t)||Ue.test(e)?"gltf":Le.test(t)||Ue.test(e)?"glb":void 0}let Ee=class extends ae{constructor(){super(),this.externalSources=new ce,this._explicitDisplaySource=null,this.addHandles(p((()=>this.externalSources),"after-remove",(({item:e})=>{e===this._explicitDisplaySource&&(this._explicitDisplaySource=null)}),{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(null!=e&&!le(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every((t=>!pe(t,e)))&&this.externalSources.add(e)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter((t=>ue(t,e)))}get _implicitDisplaySource(){return this.externalSources.find(le)}};function Te(e,t){if(e)for(let r=0;r<e.length;r+=3)for(let s=0;s<3;s++)e[r+s]+=t[s]}e([m()],Ee.prototype,"externalSources",void 0),e([m()],Ee.prototype,"displaySource",null),e([m()],Ee.prototype,"_implicitDisplaySource",null),e([m()],Ee.prototype,"_explicitDisplaySource",void 0),Ee=e([f("esri.geometry.support.meshUtils.Metadata")],Ee);const _e=h(),De=he(),$e=fe(),Be={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function Ge(e,t,r){e.isPlane||function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}(e),function(e,t){if(null==t)return;const r="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];Ne[0]=r[0],Ne[4]=r[1],Ne[8]=r[2];for(let t=0;t<e.position.length;t+=3){for(let r=0;r<3;r++)We[r]=e.position[t+r];Y(We,We,Ne);for(let r=0;r<3;r++)e.position[t+r]=We[r]}if(r[0]!==r[1]||r[1]!==r[2]){Ne[0]=1/r[0],Ne[4]=1/r[1],Ne[8]=1/r[2];for(let t=0;t<e.normal.length;t+=3){for(let r=0;r<3;r++)We[r]=e.normal[t+r];Y(We,We,Ne),ee(We,We);for(let r=0;r<3;r++)e.normal[t+r]=We[r]}}}(e,r?.size);const{vertexAttributes:s,vertexSpace:n,transform:o}=K(e,t,r);return{vertexAttributes:new R({...s,uv:e.uv}),vertexSpace:n,transform:o,components:[new S({faces:e.faces,material:r?.material||null})],spatialReference:t.spatialReference}}const Ie={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Ve={south:0,east:1,north:2,west:3,up:4,down:5},We=h(),Ne=fe(),qe="esri.geometry.support.meshUtils.rotate";function He(e,t,r,s=g){if(null!=e){xe(Qe,k(t),b(t));for(let t=0;t<e.length;t+=r){for(let r=0;r<3;r++)Ze[r]=e[t+r]-s[r];re(Ze,Ze,Qe);for(let r=0;r<3;r++)e[t+r]=Ze[r]+s[r]}}}const Ze=h(),Je=h(),Ke=j(),Qe=he(),Xe=fe(),Ye=h(),et="esri.geometry.support.meshUtils.scale";function tt(e,t,r=g){if(e)for(let s=0;s<e.length;s+=3){for(let t=0;t<3;t++)rt[t]=e[s+t]-r[t];se(rt,rt,t);for(let t=0;t<3;t++)e[s+t]=rt[t]+r[t]}}const rt=h(),st=h(),nt=h();async function ot(e){const{BlobReader:t,ZipReader:r,BlobWriter:s}=await import("../chunks/zipjs-wrapper.js"),n=[],o=new r(new t(e));return(await o.getEntries()).forEach((e=>{if(e.directory||/^__MACOS/i.test(e.filename))return;const t=new s,r=e.getData?.(t).then((t=>new File([t],e.filename)));r&&n.push(r)})),Promise.all(n)}var it;const at="esri.geometry.Mesh",ct={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:E,"georeferenced-relative":z,local:T}};let lt=it=class extends(r.LoadableMixin(n(x))){constructor(e){super(e),this.components=null,this.vertexSpace=new E,this.transform=null,this.metadata=new Ee,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new R,this.type="mesh"}initialize(){(0===this.metadata.externalSources.length||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when((()=>{this.addHandles(u((()=>({vertexAttributes:this.vertexAttributes,components:this.components?.map((e=>e.clone()))})),(()=>this._clearSources()),{once:!0,sync:!0}))}))}get hasExtent(){return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):null!=this.metadata.displaySource?.extent}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:r,vertexSpace:s}=this,n=r.position;if(0===n.length||e&&0===e.length)return new d({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if("local"===s.type){const{_untransformedExtent:e,transform:r}=this;return function({xmin:e,xmax:t,ymin:r,ymax:s,zmin:n,zmax:o},i,a,c){n??=0,o??=0,je??=new Float64Array(24);const l=je;return l[0]=e,l[1]=r,l[2]=n,l[3]=e,l[4]=s,l[5]=n,l[6]=t,l[7]=s,l[8]=n,l[9]=t,l[10]=r,l[11]=n,l[12]=e,l[13]=r,l[14]=o,l[15]=e,l[16]=s,l[17]=o,l[18]=t,l[19]=s,l[20]=o,l[21]=t,l[22]=r,l[23]=o,$({positions:l,transform:i,vertexSpace:a,inSpatialReference:c,outSpatialReference:c,outPositions:l}),ve(l,c)}(e,r,s,t)}if("georeferenced-relative"===s.type){const{transform:e}=this;return ve($({positions:n,transform:e,vertexSpace:s,inSpatialReference:t,outSpatialReference:t}),t)}return ve(n,t)}get _untransformedExtent(){return ve(this.vertexAttributes.position,this.spatialReference)}get anchor(){const{vertexSpace:e}=this;if(e.isRelative)return e.getOriginPoint(this.spatialReference);const{center:t,zmin:r}=this._transformedExtent;return new y({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get origin(){const{vertexSpace:e}=this;return e.isRelative?e.getOriginPoint(this.spatialReference):this._transformedExtent.center}get extent(){return this.loaded||null==this.metadata?.displaySource?.extent?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){if(!this.loaded)return s.getLogger(this).error("addComponent()",(new F).message);this.components||(this.components=[]),this.components.push(S.from(e)),this.notifyChange("components")}removeComponent(e){if(!this.loaded)return s.getLogger(this).error("removeComponent()",(new F).message);if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}s.getLogger(this).error("removeComponent()",(new M).message)}rotate(e,t,r,n){return A(e,t,r,ut),function(e,t,r){if(!e.vertexAttributes?.position||0===t[3])return;const{spatialReference:n,vertexSpace:o}=e;if(o.isRelative){B(o,qe,r);const s=r?.origin??e.origin;e.transform??=new _,function(e,t,r,s){const n=t.origin,o=te(Ze,s.x,s.y,s.z??0),i=Q(Ze,o,n);e.applyLocalInverse(i,Je),e.rotation=v(e.rotation,r,j()),e.applyLocalInverse(i,i),Q(i,i,Je),e.translation=X(h(),e.translation,i)}(e.transform,o,t,s)}else{const o=r?.origin??e.origin;G(n,r)?function(e,t,r){const s=e.spatialReference,n=ge(s),o=Ye;ne(r,o,n)||ne(e.origin,o,n);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),p=null!=a?new Float32Array(a.length):null,u=null!=c?new Float32Array(c.length):null;de(n,o,Qe,n),me(Xe,Qe);const m=Ke;Y(b(Ke),b(t),Xe),m[3]=t[3],W(i,s,l),null!=a&&null!=p&&N(a,i,l,s,p),null!=c&&null!=u&&q(c,i,l,s,u),He(l,m,3,o),H(l,i,s),null!=a&&null!=p&&(He(p,m,3),Z(p,i,l,s,a)),null!=c&&null!=u&&(He(u,m,4),J(u,i,l,s,c)),e.vertexAttributesChanged()}(e,t,o):function(e,t,r){const n=Ye;if(!ne(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,s.getLogger(qe).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}He(e.vertexAttributes.position,t,3,n),He(e.vertexAttributes.normal,t,3),He(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,o)}}(this,ut,n),this}offset(e,t,r,n){return this.loaded?(pt[0]=e,pt[1]=t,pt[2]=r,function(e,t,r){if(!e.vertexAttributes?.position)return;const{vertexSpace:s}=e;s.isRelative?(B(s,"esri.geometry.support.meshUtils.offset",r),function(e,t){const r=e.origin;e.origin=X(h(),r,t)}(s,t)):G(e.spatialReference,r)?function(e,t){const r=e.spatialReference,s=e.vertexAttributes.position,n=e.vertexAttributes.normal,o=e.vertexAttributes.tangent,i=new Float64Array(s.length),a=null!=n?new Float32Array(n.length):null,c=null!=o?new Float32Array(o.length):null,l=e.extent.center,p=_e;de(r,[l.x,l.y,l.z],De,ge(r)),me($e,De),Y(p,t,$e),W(s,r,i),null!=n&&null!=a&&N(n,s,i,r,a),null!=o&&null!=c&&q(o,s,i,r,c),Te(i,p),H(i,s,r),null!=n&&null!=a&&Z(a,s,i,r,n),null!=o&&null!=c&&J(c,s,i,r,o),e.vertexAttributesChanged()}(e,t):function(e,t){Te(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t)}(this,pt,n),this):(s.getLogger(this).error("offset()",(new F).message),this)}scale(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes?.position)return;const{spatialReference:n,vertexSpace:o}=e;if(o.isRelative){B(o,et,r);const s=r?.origin??e.origin;e.transform??=new _,function(e,t,r,s){const n=t.origin,o=te(rt,s.x,s.y,s.z),i=Q(rt,o,n);e.applyLocalInverse(i,st);const a=se(h(),e.scale,r);e.scale=a,e.applyLocalInverse(i,i),Q(i,i,st),e.translation=X(h(),e.translation,i)}(e.transform,o,t,s)}else{const o=G(n,r),i=r?.origin??e.origin;o?function(e,t,r){const s=e.spatialReference,n=ge(s),o=nt;ne(r,o,n)||ne(e.origin,o,n);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,l=new Float64Array(i.length),p=null!=a?new Float32Array(a.length):null,u=null!=c?new Float32Array(c.length):null;W(i,s,l),null!=a&&null!=p&&N(a,i,l,s,p),null!=c&&null!=u&&q(c,i,l,s,u),tt(l,t,o),H(l,i,s),null!=a&&null!=p&&Z(p,i,l,s,a),null!=c&&null!=u&&J(u,i,l,s,c),e.vertexAttributesChanged()}(e,t,i):function(e,t,r){const n=nt;if(!ne(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,s.getLogger(et).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}tt(e.vertexAttributes.position,t,n),e.vertexAttributesChanged()}(e,t,i)}}(this,e,t),this):(s.getLogger(this).error("scale()",(new F).message),this)}centerAt(e,t){return this.loaded?(function(e,t,r){if(!e.vertexAttributes?.position)return;const{vertexSpace:n}=e,o=r?.origin??e.origin;n.isRelative?(B(n,ke,r),function(e,t,r){const{vertexSpace:n}=e;if(!n.isRelative)return;const o=Ae,i=be;if(!ne(t,i,e.spatialReference))return void s.getLogger(ke).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`);if(!ne(r,o,e.spatialReference)){const t=e.origin;o[0]=t.x,o[1]=t.y,o[2]=t.z,s.getLogger(ke).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}const a=Q(Se,i,o),c=n.origin;n.origin=X(h(),c,a)}(e,t,o)):G(e.spatialReference,r)?function(e,t,r){const s=I(e.vertexAttributes,r,{geographic:!0}),{position:n,normal:o,tangent:i}=V(s,t,{geographic:!0});e.vertexAttributes.position=n,e.vertexAttributes.normal=o,e.vertexAttributes.tangent=i,e.vertexAttributesChanged()}(e,t,o):function(e,t,r){const n=Ae,o=be;if(ne(t,o,e.spatialReference)){if(!ne(r,n,e.spatialReference)){const t=e.origin;n[0]=t.x,n[1]=t.y,n[2]=t.z,s.getLogger(ke).error(`Failed to project specified origin (wkid:${r.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}(function(e,t,r){if(e)for(let s=0;s<e.length;s+=3)for(let n=0;n<3;n++)e[s+n]+=t[n]-r[n]})(e.vertexAttributes.position,o,n),e.vertexAttributesChanged()}else s.getLogger(ke).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}(e,t,o)}(this,e,t),this):(s.getLogger(this).error("centerAt()",(new F).message),this)}load(e){const{metadata:{displaySource:r}}=this;return r&&this.addResolvingPromise(async function(e,r,s){const{source:n}=r,{loadGLTFMesh:p}=await o(import("../chunks/loadGLTFMesh.js"),s),u=await async function(e,r){if(Array.isArray(e)){if(!e.length)throw new t("mesh-load-external:missing-assets","There must be at least one file to load");return e[0]instanceof File?Oe(e.map((e=>({name:e.name,mimeType:e.type,source:Fe(e)})))):async function(e,t){const r=await a(e.map((async e=>{const r=await async function(e,t){const{parts:r,assetMimeType:s,assetName:n}=e;if(1===r.length)return new Ce(r[0].partUrl);const o=await e.toBlob(t);return i(t),Ce.fromBlob(o,ze(n,s))}(e);return i(t),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(c(t))throw r.forEach((e=>e.source.dispose())),l();return Oe(r)}(e,r)}return Fe(e)}(n,s);i(s);const m=p(new y({x:0,y:0,z:0,spatialReference:e.spatialReference}),u.url,{resolveFile:Re(u),requestFile:void 0,useTransform:!0,signal:s?.signal,expectedType:u.type});m.then((()=>u.dispose()),(()=>u.dispose()));const{vertexAttributes:f,components:h}=await m;e.vertexAttributes=f,e.components=h}(this,r,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(e){let t=null;if(this.components){const e=new Map,r=new Map;t=this.components.map((t=>t.cloneWithDeduplication(e,r)))}const r={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:e,transform:this.transform?.clone()??null,metadata:this.metadata.clone()};return new it(r)}cloneShallow(){return new it({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=import("../chunks/gltfexport.js"),r=this.load(),s=await Promise.all([t,r]),{toBinaryGLTF:n}=s[0];return n(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,null!=this.components)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}static createBox(e,t){if(!(e instanceof y))return s.getLogger(at).error(".createBox()",(new L).message),null;const r=new it(Ge(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:r}=Ie,s=4*e.length,n=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array(2*e.length*3);let c=0,l=0,p=0,u=0;for(let s=0;s<e.length;s++){const m=e[s],f=c/3;for(const e of t)a[u++]=f+e;const h=m.corners;for(let e=0;e<4;e++){const t=h[e];let s=0;i[p++]=.25*r[e][0]+m.uvOrigin[0],i[p++]=m.uvOrigin[1]-.25*r[e][1];for(let e=0;e<3;e++)0!==m.axis[e]?(n[c++]=.5*m.axis[e],o[l++]=m.axis[e]):(n[c++]=.5*t[s++],o[l++]=0)}}return{position:n,normal:o,uv:i,faces:a}}(),e,t));return t?.imageFace&&"all"!==t.imageFace?function(e,t){const r=e.components[0],s=r.faces,n=Ve[t],o=6*n,i=new Array(6),a=new Array(s.length-6);let c=0,l=0;for(let e=0;e<s.length;e++)e>=o&&e<o+6?i[c++]=s[e]:a[l++]=s[e];if(null!=e.vertexAttributes.uv){const t=new Float32Array(e.vertexAttributes.uv),r=4*n*2,s=[0,1,1,1,1,0,0,0];for(let e=0;e<s.length;e++)t[r+e]=s[e];e.vertexAttributes.uv=t}return e.components=[new S({faces:i,material:r.material}),new S({faces:a})],e}(r,t.imageFace):r}static createSphere(e,t){return e instanceof y?new it(Ge(function(e=0){const t=Math.round(8*2**e),r=2*t,s=(t-1)*(r+1)+2*r,n=new Float64Array(3*s),o=new Float32Array(3*s),i=new Float32Array(2*s),a=new Uint32Array((t-1)*r*2*3);let c=0,l=0,p=0,u=0;for(let e=0;e<=t;e++){const s=e/t*Math.PI+.5*Math.PI,m=Math.cos(s),f=Math.sin(s);We[2]=f;const h=0===e||e===t,g=h?r-1:r;for(let s=0;s<=g;s++){const f=s/g*2*Math.PI;We[0]=-Math.sin(f)*m,We[1]=Math.cos(f)*m;for(let e=0;e<3;e++)n[c]=.5*We[e],o[c]=We[e],++c;i[l++]=(s+(h?.5:0))/r,i[l++]=e/t,0!==e&&s!==r&&(e!==t&&(a[p++]=u,a[p++]=u+1,a[p++]=u-r),1!==e&&(a[p++]=u,a[p++]=u-r,a[p++]=u-r-1)),u++}}return{position:n,normal:o,uv:i,faces:a}}(t?.densificationFactor||0),e,t)):(s.getLogger(at).error(".createSphere()",(new L).message),null)}static createCylinder(e,t){return e instanceof y?new it(Ge(function(e=0){const t=Math.round(16*2**e),r=4*(t+1)+2*t,s=new Float64Array(3*r),n=new Float32Array(3*r),o=new Float32Array(2*r),i=new Uint32Array(4*t*3);let a=0,c=0,l=0,p=0,u=0;for(let e=0;e<=5;e++){const r=0===e||5===e,m=e<=1||e>=4,f=2===e||4===e,h=r?t-1:t;for(let g=0;g<=h;g++){const d=g/h*2*Math.PI,x=r?0:.5;We[0]=x*Math.sin(d),We[1]=x*-Math.cos(d),We[2]=e<=2?.5:-.5;for(let t=0;t<3;t++)s[a++]=We[t],n[c++]=m?2===t?e<=1?1:-1:0:2===t?0:We[t]/x;o[l++]=(g+(r?.5:0))/t,o[l++]=e<=1?1*e/3:e<=3?1*(e-2)/3+1/3:1*(e-4)/3+2/3,f||0===e||g===t||(5!==e&&(i[p++]=u,i[p++]=u+1,i[p++]=u-t),1!==e&&(i[p++]=u,i[p++]=u-t,i[p++]=u-t-1)),u++}}return{position:s,normal:n,uv:o,faces:i}}(t?.densificationFactor||0),e,t)):(s.getLogger(at).error(".createCylinder()",(new L).message),null)}static createPlane(e,t){if(!(e instanceof y))return s.getLogger(at).error(".createPlane()",(new L).message),null;const r=t?.facing??"up",n=function(e,t){const r="number"==typeof t?t:null!=t?t.width:1,s="number"==typeof t?t:null!=t?t.height:1;switch(e){case"up":case"down":return{width:r,depth:s};case"north":case"south":return{width:r,height:s};case"east":case"west":return{depth:r,height:s}}}(r,t?.size);return new it(Ge(function(e){const t=Be.facingAxisOrderSwap[e],r=Be.position,s=Be.normal,n=new Float64Array(r.length),o=new Float32Array(s.length);let i=0;for(let e=0;e<4;e++){const e=i;for(let a=0;a<3;a++){const c=t[a],l=Math.abs(c)-1,p=c>=0?1:-1;n[i]=r[e+l]*p,o[i]=s[e+l]*p,i++}}return{position:n,normal:o,uv:new Float32Array(Be.uv),faces:new Uint32Array(Be.faces),isPlane:!0}}(r),e,{...t,size:n}))}static createFromPolygon(e,t){if(!(e instanceof w))return s.getLogger(at).error(".createFromPolygon()",(new U).message),null;const r=D(e);return new it({vertexAttributes:new R({position:r.position}),components:[new S({faces:r.faces,shading:"flat",material:t?.material??null})],spatialReference:e.spatialReference,vertexSpace:new E})}static async createFromGLTF(e,t,r){if(!(e instanceof y)){const e=new L;throw s.getLogger(at).error(".createfromGLTF()",e.message),e}const{loadGLTFMesh:n}=await o(import("../chunks/loadGLTFMesh.js"),r);return new it(await n(e,t,r))}static async createFromFiles(e,t,r){const n=e=>s.getLogger(at).error(".createFromFiles()",e.message);if(!(e instanceof y)){const e=new L;throw n(e),e}const o=r?.layer;if(!o){const e=new P;throw n(e),e}const i=await it.extractAndFilterFiles(t,o),a=i.reduce(((e,t)=>ye(o.infoFor3D,t)?e+1:e),0);if(0===a){const e=new O;throw n(e),e}if(a>1){const e=new C;throw n(e),e}const c=it.createWithExternalSource(e,i),[l]=await o.uploadAssets([c],r);return l}static async extractAndFilterFiles(e,t){const r=t?.infoFor3D;if(!r)return e;const s=await async function(e){const t=[];for(const r of e)r.name.toLowerCase().endsWith(".zip")?t.push(ot(r)):t.push(Promise.resolve(r));return(await Promise.all(t)).flat()}(e);return s.filter((e=>we(r,e)))}static createWithExternalSource(e,t,r){const s=r?.extent??null,{x:n,y:o,z:i,spatialReference:a}=e,c=r?.transform?.clone()??new _,l=r?.vertexSpace??new T({origin:[n,o,i??0]}),p={source:t,extent:s},u=new Ee;return u.externalSources.push(p),new it({metadata:u,transform:c,vertexSpace:l,spatialReference:a})}static createIncomplete(e,r){const{x:s,y:n,z:o,spatialReference:i}=e,a=r?.transform?.clone()??new _,c=r?.vertexSpace??new T({origin:[s,n,o??0]}),l=new it({transform:a,vertexSpace:c,spatialReference:i});return l.addResolvingPromise(Promise.reject(new t("mesh-incomplete","Mesh resources are not complete"))),l}};e([m({type:[S],json:{write:!0}})],lt.prototype,"components",void 0),e([m({nonNullable:!0,types:ct,constructOnly:!0,json:{write:!0}})],lt.prototype,"vertexSpace",void 0),e([m({type:_,json:{write:!0}})],lt.prototype,"transform",void 0),e([m({constructOnly:!0})],lt.prototype,"metadata",void 0),e([m()],lt.prototype,"hasExtent",null),e([m()],lt.prototype,"_transformedExtent",null),e([m()],lt.prototype,"_untransformedExtent",null),e([m()],lt.prototype,"anchor",null),e([m()],lt.prototype,"origin",null),e([m({readOnly:!0,json:{read:!1}})],lt.prototype,"extent",null),e([m({readOnly:!0,json:{read:!1,write:!0,default:!0}})],lt.prototype,"hasZ",void 0),e([m({readOnly:!0,json:{read:!1,write:!0,default:!1}})],lt.prototype,"hasM",void 0),e([m({type:R,nonNullable:!0,json:{write:!0}})],lt.prototype,"vertexAttributes",void 0),lt=it=e([f(at)],lt);const pt=h(),ut=j(),mt=lt;export{mt as default};
