/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import t from"../Color.js";import e from"../request.js";import s from"../core/Error.js";import"./typedArrayUtil.js";import{n as o,L as i}from"./Logger.js";import{L as r}from"./LRUCache.js";import{isAbortError as n}from"../core/promiseUtils.js";import{V as l}from"./Version.js";import m from"../layers/support/FieldsIndex.js";import{l as a,c}from"./arcadeOnDemand.js";import p from"../symbols/CIMSymbol.js";import"./colorUtils.js";import"./mathUtils.js";import"./vec3.js";import"./vec3f64.js";import"./common.js";import"./ensureType.js";import"../config.js";import"../core/lang.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"../core/accessorSupport/decorators/property.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./time.js";import"./MemCache.js";import"./UnknownTimeZone.js";import"./datetime.js";import"../layers/support/fieldUtils.js";import"../core/sql.js";import"../intl.js";import"./date.js";import"./jsonMap.js";import"./locale.js";import"./timeZoneUtils.js";import"./messages.js";import"./assets.js";import"../geometry.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./Ellipsoid.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./Axis.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"./enumeration.js";import"../symbols/Symbol.js";const y="esri.renderers.support.DictionaryLoader",u={type:"CIMSimpleLineCallout",lineSymbol:{type:"CIMLineSymbol",symbolLayers:[{type:"CIMSolidStroke",width:.5,color:[0,0,0,255]}]}};class f{constructor(t,e,s){this.config=null,this.fieldMap=null,this.url=null,this._ongoingRequests=new Map,this._symbolCache=new r(100),this._dictionaryVersion=null,this._fieldIndex=null,this._dictionaryPromise=null,this.url=t,this.config=e,this.fieldMap=s}getSymbolFields(){return this._symbolFields}async getSymbolAsync(e,s){let i;this._dictionaryPromise||(this._dictionaryPromise=this.fetchResources(s));try{i=await this._dictionaryPromise}catch(t){if(n(t))return this._dictionaryPromise=null,null}const r=this._dictionaryVersion&&this._dictionaryVersion.since(4,0),l={};if(this.fieldMap)for(const t of this._symbolFields){const s=this._getFieldName(this.fieldMap[t]);if(s){const o=e.attributes[s];l[t]=r?o:null!=o?""+e.attributes[s]:""}else l[t]=""}let m=null;try{m=i?.(l,s)}catch(t){return null}if(!m||"string"!=typeof m)return null;const a=o(m).toString(),c=this._symbolCache.get(a);if(c)return c.catch((()=>{this._symbolCache.pop(a)})),c;const p=m.split(";"),y=[],u=[];for(const e of p)if(e)if(e.includes("po:")){const s=e.substr(3).split("|");if(3===s.length){const e=s[0],o=s[1];let i=s[2];if("DashTemplate"===o)i=i.split(" ").map((t=>Number(t)));else if("Color"===o){const e=new t(i).toRgba();i=[e[0],e[1],e[2],255*e[3]]}else i=Number(i);u.push({primitiveName:e,propertyName:o,value:i})}}else if(e.includes("|")){for(const t of e.split("|"))if(this._itemNames.has(t)){y.push(t);break}}else this._itemNames.has(e)&&y.push(e);const f=null==e.geometry||!e.geometry.hasZ&&"point"===e.geometry.type,h=this._cimPartsToCIMSymbol(y,u,f,s);return this._symbolCache.put(a,h,1),h}async fetchResources(t){if(this._dictionaryPromise)return this._dictionaryPromise;if(!this.url)return void i.getLogger(y).error("no valid URL!");const o=e(this.url+"/resources/styles/dictionary-info.json",{responseType:"json",query:{f:"json"},signal:null!=t?t.signal:null}),[{data:r}]=await Promise.all([o,a()]);if(!r)throw this._dictionaryPromise=null,new s("esri.renderers.DictionaryRenderer","Bad dictionary data!");const{authoringInfo:n,dictionary_version:p,expression:u,itemsNames:f}=r,h=u;let d=!1;p&&(this._dictionaryVersion=l.parse(p),d=this._dictionaryVersion.since(4,0)),this._refSymbolUrlTemplate=this.url+"/"+r.cimRefTemplateUrl,this._itemNames=new Set(f),this._symbolFields=n.symbol;const j={};if(this.config){const t=this.config;for(const e in t)j[e]=t[e]}if(n.configuration)for(const t of n.configuration)j.hasOwnProperty(t.name)||(j[t.name]=t.value);const g=[];if(t?.fields&&this.fieldMap)for(const e of this._symbolFields){const s=this.fieldMap[e],o=t.fields.filter((t=>t.name.toLowerCase()===s?.toLowerCase()));o.length>0&&g.push({...o[0],type:d?o[0].type:"esriFieldTypeString"})}g.length>0&&(this._fieldIndex=new m(g));const b=c(h,null!=t?t.spatialReference:null,g,j).then((t=>{const e={scale:0};return(s,o)=>{if(null==t)return null;const i=t.repurposeFeature({geometry:null,attributes:s});return e.scale=null!=o?o.scale??void 0:void 0,t.evaluate({$feature:i,$view:e},t.services)}})).catch((t=>(i.getLogger(y).error("Creating dictinoary expression failed:",t),null)));return this._dictionaryPromise=b,b}async _cimPartsToCIMSymbol(t,e,s,o){const i=new Array(t.length);for(let e=0;e<t.length;e++)i[e]=this._getSymbolPart(t[e],o);const r=await Promise.all(i),n=this.fieldMap;if(n)for(const t of r)h(t,n);return new p({data:this._combineSymbolParts(r,e,s)})}async _getSymbolPart(t,s){if(this._ongoingRequests.has(t))return this._ongoingRequests.get(t).then((t=>t.data));const o=this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi,t),i=e(o,{responseType:"json",query:{f:"json"},...s});this._ongoingRequests.set(t,i);try{return(await i).data}catch(e){throw this._ongoingRequests.delete(t),e}}_combineSymbolParts(t,e,s){if(!t||0===t.length)return null;const o={...t[0]};if(t.length>1){o.symbolLayers=[];for(const e of t){const t=e;o.symbolLayers.unshift(...t.symbolLayers)}}return s&&(o.callout=u),{type:"CIMSymbolReference",symbol:o,primitiveOverrides:e}}_getFieldName(t){if(null!==this._fieldIndex){const e=this._fieldIndex.get(t);return e?e.name:t}return t}}function h(t,e){if(!t)return;const s=t.symbolLayers;if(!s)return;let o=s.length;for(;o--;){const t=s[o];t&&!1!==t.enable&&"CIMVectorMarker"===t.type&&d(t,e)}}function d(t,e){const s=t.markerGraphics;if(s)for(const t of s){if(!t)continue;const s=t.symbol;if(s)switch(s.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":h(s,e);break;case"CIMTextSymbol":s.fieldMap=e}}}export{f as DictionaryLoader};
