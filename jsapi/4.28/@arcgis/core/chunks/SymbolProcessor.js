/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{b as t}from"./shapingUtils.js";import"../core/Error.js";import"./typedArrayUtil.js";import"./Logger.js";import{b as s}from"./maybe.js";import{isAbortError as r,throwIfAborted as i}from"../core/promiseUtils.js";import"./ensureType.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{d as a,h as n}from"./diffUtils.js";import l from"../geometry/SpatialReference.js";import{k as m}from"./visualVariablesUtils.js";import{b as c}from"./enums4.js";import{a as p,c as u,b as d,M as h,d as f}from"./Matcher.js";import{B as g}from"./BaseProcessor.js";import"./BidiEngine.js";import"./screenUtils.js";import"./mat2d.js";import"./mat2df32.js";import"./vec2.js";import"./common.js";import"./vec2f32.js";import"./alignmentUtils.js";import"./number.js";import"./Rect.js";import"../core/lang.js";import"../config.js";import"./handleUtils.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"../core/Accessor.js";import"../core/Handles.js";import"../core/accessorSupport/decorators/property.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./time.js";import"../core/Collection.js";import"../core/Evented.js";import"./shared.js";import"./SimpleObservable.js";import"../core/JSONSupport.js";import"./unitUtils.js";import"./jsonMap.js";import"./Ellipsoid.js";import"./assets.js";import"../request.js";import"../kernel.js";import"../core/urlUtils.js";import"./writer.js";import"./color.js";import"./enums.js";import"./enums3.js";import"./VertexElementDescriptor.js";import"./definitions.js";import"./TileInfoView.js";import"./TileKey2.js";import"./TileStrategy.js";import"./QueueProcessor.js";import"./Queue.js";import"../core/signal.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"./vec3.js";import"./vec3f64.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"./reader.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./tileUtils.js";import"./libtess.js";import"./MaterialKey.js";import"./labelPoint.js";import"../geometry/Polygon.js";import"./Axis.js";import"./extentUtils.js";import"./zmUtils.js";import"../geometry/support/jsonUtils.js";import"../geometry/Multipoint.js";import"../geometry/Polyline.js";import"./OptimizedGeometry.js";import"./CIMSymbolHelper.js";import"../Color.js";import"./colorUtils.js";import"./arcadeOnDemand.js";import"../geometry.js";import"./typeUtils.js";import"../symbols/Font.js";import"./fontUtils.js";import"./GeometryUtils.js";import"./utils9.js";import"./callExpressionWithFeature.js";import"./quantizationUtils.js";import"./cimAnalyzer.js";import"./floatRGBA.js";import"./defaultsJSON.js";import"./GeometryUtils2.js";import"./earcut.js";import"./_commonjsHelpers.js";import"./TurboLine.js";import"./LRUCache.js";import"./MemCache.js";import"./ExpandedCIM.js";class y{constructor(e){this._remoteClient=e,this._resourceMap=new Map,this._inFlightResourceMap=new Map,this.geometryEngine=null,this.geometryEnginePromise=null}destroy(){}async fetchResource(e,t){const s=this._resourceMap,i=s.get(e);if(i)return i;let o=this._inFlightResourceMap.get(e);if(o)return o;try{o=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...t}),this._inFlightResourceMap.set(e,o),o.then((t=>(this._inFlightResourceMap.delete(e),s.set(e,t),t)))}catch(e){return r(e)?null:{width:0,height:0}}return o}getResource(e){return this._resourceMap.get(e)??null}loadFont(e){return Promise.resolve(null)}}function j(e,t){const s=t-t/4,r=t+t/2;return(!e.minScale||e.minScale>=s)&&(!e.maxScale||e.maxScale<=r)}function _(e){const t=e.message,s={message:{data:{},tileKey:t.tileKey,tileKeyOrigin:t.tileKeyOrigin,version:t.version},transferList:new Array};for(const e in t.data){const r=e,i=t.data[r];if(s.message.data[r]=null,null!=i){const e=i.stride,t=i.indices.slice(0),o=i.vertices.slice(0),a=i.records.slice(0),n=i.metrics?.slice(0),l={stride:e,indices:t,vertices:o,records:a,metrics:n};s.transferList.push(t,o,a),s.message.data[r]=l}}return s}let b=class extends g{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.addHandles([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new y(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(e){this._bufferIds.forEach((t=>{t.forEach(e)}))}async update(e,t){const s=t.schema.processors[0];if("symbol"!==s.type)return;const r=a(this._schema,s);(n(r,"mesh")||n(r,"target"))&&(e.mesh=!0,e.why?.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(e,t,s,r){return i(r),this._onTileData(e,t,s,r)}onTileClear(e,t){const s={clear:!0,end:t};return this._bufferData.delete(e.key.id),this._bufferIds.delete(e.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:s})}onTileError(e,t,s){const r=s.signal,i={tileKey:e.id,error:t};return this.remoteClient.invoke("tileRenderer.onTileError",i,{signal:r})}onTileUpdate(e){for(const t of e.removed)this._bufferData.has(t.key.id)&&this._bufferData.delete(t.key.id),this._bufferIds.has(t.key.id)&&this._bufferIds.delete(t.key.id);for(const t of e.added)this._bufferData.forEach((e=>{for(const s of e)s.message.tileKey===t.id&&this._updateTileMesh("append",t,_(s),[],!1,!1,null)}))}_addBufferData(e,t){this._bufferData.has(e)||this._bufferData.set(e,[]),this._bufferData.get(e)?.push(_(t))}_createFactory(e){const{geometryType:t,objectIdField:s,fields:r}=this.service,i={geometryType:t,fields:r,spatialReference:l.fromJSON(this.spatialReference)},o=new p(((e,t)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",e,t)),this.tileStore.tileScheme.tileInfo),{matcher:a,aggregateMatcher:n}=e.mesh;return this._store=o,this._matchers.feature=u(a,o,i,this._resourceManagerProxy),this._matchers.aggregate=n?u(n,o,i,this._resourceManagerProxy):null,new d(t,s,o)}async _onTileData(e,t,s,r){i(r);const{type:o,addOrUpdate:a,remove:n,clear:l,end:m}=t,c=!!this._schema.mesh.sortKey;if(!a){const t={type:o,addOrUpdate:null,remove:n,clear:l,end:m,sort:c};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const p=this._processFeatures(e,a,s,r,t.status?.version);try{const s=await p;if(null==s){const t={type:o,addOrUpdate:null,remove:n,clear:l,end:m,sort:c};return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:e.id,data:t},r)}const i=[];for(const t of s){let s=!1;const r=t.message.bufferIds,o=e.key.id,a=t.message.tileKey;if(o!==a&&null!=r){if(!this.tileStore.get(a)){this._addBufferData(o,t),i.push(t);continue}let e=this._bufferIds.get(a);e||(e=new Set,this._bufferIds.set(a,e));const n=Array.from(r);for(const t of n){if(e.has(t)){s=!0;break}e.add(t)}}s||(this._addBufferData(o,t),i.push(t))}await Promise.all(i.map((s=>{const i=e.key.id===s.message.tileKey,a=i?t.remove:[],n=i&&t.end;return this._updateTileMesh(o,e,s,a,n,!!t.clear,r.signal)})))}catch(t){this._handleError(e,t,r)}}async _updateTileMesh(e,t,s,r,o,a,n){const l=e,m=s.message.tileKey,c=!!this._schema.mesh.sortKey;m!==t.key.id&&(o=!1);const p=s?.message,u={type:l,addOrUpdate:p,remove:r,clear:a,end:o,sort:c},d={transferList:s?.transferList??[],signal:n};return i(d),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:m,data:u},d)}async _processFeatures(e,t,s,r,o){if(null==t||!t.hasFeatures)return null;const a={transform:e.transform,hasZ:!1,hasM:!1},n=this._factory,l={viewingMode:"",scale:e.scale},m=await this._matchers.feature,c=await this._matchers.aggregate;i(r);const p=this._getLabelInfos(e,t);return await n.analyze(t.getCursor(),this._resourceManagerProxy,m,c,a,l),i(r),this._writeFeatureSet(e,t,a,p,n,s,o)}_writeFeatureSet(e,t,s,r,i,o,a){const n=t.getSize(),l=this._schema.mesh.matcher.symbologyType,m=new h(e.key.id,{features:n,records:n,metrics:0},l,o,l!==c.HEATMAP,a),p={viewingMode:"",scale:e.scale},u=t.getCursor();for(;u.next();)try{const t=u.getDisplayId(),o=null!=r?r.get(t):null;i.writeCursor(m,u,s,p,e.level,o,this._resourceManagerProxy)}catch(e){}const d=e.tileInfoView.tileInfo.isWrappable;return m.serialize(d)}_handleError(e,t,s){if(!r(t)){const r={tileKey:e.id,error:t.message};return this.remoteClient.invoke("tileRenderer.onTileError",r,{signal:s.signal})}return Promise.resolve()}_getLabelingSchemaForScale(e){const t=this._schema.mesh.labels;if(null==t)return null;if("subtype"===t.type){const s={type:"subtype",classes:{}};let r=!1;for(const i in t.classes){const o=t.classes[i].filter((t=>j(t,e.scale)));r=r||!!o.length,s.classes[i]=o}return r?s:null}const s=t.classes.filter((t=>j(t,e.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(e,t){if("subtype"===t.type){const r=this.service.subtypeField;s(r,"Expected to find subtype Field");const i=e.readAttribute(r);return null==i?[]:t.classes[i]??[]}return t.classes}_getLabelInfos(e,s){const r=this._getLabelingSchemaForScale(e);if(null==r)return null;const i=new Map,o=s.getCursor();for(;o.next();){const e=o.getDisplayId(),s=[],a=m(e),n=a&&1!==o.readAttribute("cluster_count")?"aggregate":"feature",l=this._getLabels(o,r);for(const r of l){if(r.target!==n)continue;const i=o.getStorage(),l=a&&"feature"===n?i.getComputedStringAtIndex(o.readAttribute("referenceId"),r.fieldIndex):i.getComputedStringAtIndex(e,r.fieldIndex);if(!l)continue;const m=t(l.toString()),c=m[0],p=m[1];this._store.getMosaicItem(r.symbol,f(c)).then((e=>{s[r.index]={glyphs:e.glyphMosaicItems??[],rtl:p,index:r.index}}))}i.set(e,s)}return i}};b=e([o("esri.views.2d.layers.features.processors.SymbolProcessor")],b);const M=b;export{M as default};
