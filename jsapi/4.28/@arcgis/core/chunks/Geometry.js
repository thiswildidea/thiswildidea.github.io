/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{I as t,b as i}from"./mat4f64.js";import{g as e,a as s,s as n,d as r,q as a,w as o,t as h}from"./vec3.js";import{c as u,a as c}from"./Indices.js";import{p as l,q as d,e as m}from"./typedArrayUtil.js";import{O as f}from"./basicInterfaces.js";import{P as g}from"./PooledArray.js";import{f as b,a as _,c as p}from"./vec3f64.js";import{a as I}from"./Util.js";import{a as P,C as x}from"./ContentObject.js";import{a as A}from"./triangle.js";import{g as v}from"../core/Accessor.js";import{V as y}from"./VertexAttribute.js";import{e as M}from"./doublePrecisionUtils.js";function O(t){if(t.length<l)return Array.from(t);if(d(t))return Float64Array.from(t);if(!("BYTES_PER_ELEMENT"in t))return Array.from(t);switch(t.BYTES_PER_ELEMENT){case 1:return Uint8Array.from(t);case 2:return m(t)?Uint16Array.from(t):Int16Array.from(t);case 4:return Float32Array.from(t);default:return Float64Array.from(t)}}class j{constructor(t,i,s){this.primitiveIndices=t,this._numIndexPerPrimitive=i,this.position=s,this._children=void 0,I(t.length>=1),I(3===s.size||4===s.size);const{data:n,size:r,indices:a}=s;I(a.length%this._numIndexPerPrimitive==0),I(a.length>=t.length*this._numIndexPerPrimitive);const o=t.length;let h=r*a[this._numIndexPerPrimitive*t[0]];w.clear(),w.push(h);const u=b(n[h],n[h+1],n[h+2]),c=_(u);for(let i=0;i<o;++i){const e=this._numIndexPerPrimitive*t[i];for(let t=0;t<this._numIndexPerPrimitive;++t){h=r*a[e+t],w.push(h);let i=n[h];u[0]=Math.min(i,u[0]),c[0]=Math.max(i,c[0]),i=n[h+1],u[1]=Math.min(i,u[1]),c[1]=Math.max(i,c[1]),i=n[h+2],u[2]=Math.min(i,u[2]),c[2]=Math.max(i,c[2])}}this.bbMin=u,this.bbMax=c;const l=e(p(),this.bbMin,this.bbMax,.5);this.radius=.5*Math.max(Math.max(c[0]-u[0],c[1]-u[1]),c[2]-u[2]);let d=this.radius*this.radius;for(let t=0;t<w.length;++t){h=w.at(t);const i=n[h]-l[0],e=n[h+1]-l[1],s=n[h+2]-l[2],r=i*i+e*e+s*s;if(r<=d)continue;const a=Math.sqrt(r),o=.5*(a-this.radius);this.radius=this.radius+o,d=this.radius*this.radius;const u=o/a;l[0]+=i*u,l[1]+=e*u,l[2]+=s*u}this.center=l,w.clear()}getChildren(){if(this._children||s(this.bbMin,this.bbMax)<=1)return this._children;const t=e(p(),this.bbMin,this.bbMax,.5),i=this.primitiveIndices.length,n=new Uint8Array(i),r=new Array(8);for(let t=0;t<8;++t)r[t]=0;const{data:a,size:o,indices:h}=this.position;for(let e=0;e<i;++e){let i=0;const s=this._numIndexPerPrimitive*this.primitiveIndices[e];let u=o*h[s],c=a[u],l=a[u+1],d=a[u+2];for(let t=1;t<this._numIndexPerPrimitive;++t){u=o*h[s+t];const i=a[u],e=a[u+1],n=a[u+2];i<c&&(c=i),e<l&&(l=e),n<d&&(d=n)}c<t[0]&&(i|=1),l<t[1]&&(i|=2),d<t[2]&&(i|=4),n[e]=i,++r[i]}let u=0;for(let t=0;t<8;++t)r[t]>0&&++u;if(u<2)return;const c=new Array(8);for(let t=0;t<8;++t)c[t]=r[t]>0?new Uint32Array(r[t]):void 0;for(let t=0;t<8;++t)r[t]=0;for(let t=0;t<i;++t){const i=n[t];c[i][r[i]++]=this.primitiveIndices[t]}this._children=new Array;for(let t=0;t<8;++t)void 0!==c[t]&&this._children.push(new j(c[t],this._numIndexPerPrimitive,this.position));return this._children}static prune(){w.prune()}}const w=new g({deallocator:null}),L=p(),E=p(),T=p(),C=p();class z{constructor(t){this.channel=t,this.id=v()}}function N(t,i){return null==t&&(t=[]),t.push(i),t}function S(t,i){if(null==t)return null;const e=t.filter((t=>t!==i));return 0===e.length?null:e}function U(t,i,e,s,n){B[0]=t.get(i,0),B[1]=t.get(i,1),B[2]=t.get(i,2),M(B,F,3),e.set(n,0,F[0]),s.set(n,0,F[1]),e.set(n,1,F[2]),s.set(n,1,F[3]),e.set(n,2,F[4]),s.set(n,2,F[5])}const B=p(),F=new Float32Array(6);class q extends P{constructor(t,i,e=null,s=x.Mesh,n=null,r=-1){super(),this.material=t,this.mapPositions=e,this.type=s,this.objectAndLayerIdColor=n,this.edgeIndicesLength=r,this.visible=!0,this._attributes=new Map,this._boundingInfo=null;for(const[t,e]of i)this._attributes.set(t,{...e,indices:u(e.indices)}),t===y.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._attributes.get(t).indices.length:this.edgeIndicesLength)}instantiate(t={}){const i=new q(t.material||this.material,[],this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._attributes.forEach(((t,e)=>{t.exclusive=!1,i._attributes.set(e,t)})),i._boundingInfo=this._boundingInfo,i.transformation=t.transformation||this.transformation,i}get attributes(){return this._attributes}getMutableAttribute(t){let i=this._attributes.get(t);return i&&!i.exclusive&&(i={...i,exclusive:!0,data:O(i.data)},this._attributes.set(t,i)),i}setAttributeData(t,i){const e=this._attributes.get(t);e&&this._attributes.set(t,{...e,exclusive:!0,data:i})}get indexCount(){const t=this._attributes.values().next().value.indices;return t?.length??0}get faceCount(){return this.indexCount/3}get boundingInfo(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===x.Mesh?this._computeAttachmentOriginTriangles(t):this.type===x.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(null!=this._transformation&&h(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){return function(t,i){if(!t)return!1;const{size:e,data:s,indices:o}=t;n(i,0,0,0),n(C,0,0,0);let h=0,u=0;for(let t=0;t<o.length-2;t+=3){const c=o[t]*e,l=o[t+1]*e,d=o[t+2]*e;n(L,s[c],s[c+1],s[c+2]),n(E,s[l],s[l+1],s[l+2]),n(T,s[d],s[d+1],s[d+2]);const m=A(L,E,T);m?(r(L,L,E),r(L,L,T),a(L,L,1/3*m),r(i,i,L),h+=m):(r(C,C,L),r(C,C,E),r(C,C,T),u+=3)}return!(0===u&&0===h||(0!==h?(a(i,i,1/h),0):0===u||(a(i,C,1/u),0)))}(this.attributes.get(y.POSITION),t)}_computeAttachmentOriginLines(t){const i=this.attributes.get(y.POSITION);return function(t,i,e){if(!t)return!1;n(e,0,0,0),n(C,0,0,0);let s=0,h=0;const{size:u,data:c,indices:l}=t,d=l.length-1,m=d+(i?2:0);for(let t=0;t<m;t+=2){const i=t<d?t+1:0,n=l[t<d?t:d]*u,m=l[i]*u;L[0]=c[n],L[1]=c[n+1],L[2]=c[n+2],E[0]=c[m],E[1]=c[m+1],E[2]=c[m+2],a(L,r(L,L,E),.5);const f=o(L,E);f>0?(r(e,e,a(L,L,f)),s+=f):0===s&&(r(C,C,L),h++)}return 0!==s?(a(e,e,1/s),!0):0!==h&&(a(e,C,1/h),!0)}(i,function(t,i){return!(!("isClosed"in t)||!t.isClosed)&&i.indices.length>2}(this.material.parameters,i),t)}_computeAttachmentOriginPoints(t){return function(t,i){if(!t)return!1;const{size:e,data:s,indices:r}=t;n(i,0,0,0);let o=-1,h=0;for(let t=0;t<r.length;t++){const n=r[t]*e;o!==n&&(i[0]+=s[n],i[1]+=s[n+1],i[2]+=s[n+2],h++),o=n}return h>1&&a(i,i,1/h),h>0}(this.attributes.get(y.POSITION),t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.attributes.get(y.POSITION);if(!t||0===t.indices.length)return null;const i=this.type===x.Mesh?3:1;I(t.indices.length%i==0,"Indexing error: "+t.indices.length+" not divisible by "+i);const e=c(t.indices.length/i);return new j(e,i,t)}get transformation(){return this._transformation??t}set transformation(e){this._transformation=e&&e!==t?i(e):null}addHighlight(){const t=new z(f.Highlight);return this.highlights=N(this.highlights,t),t}removeHighlight(t){this.highlights=S(this.highlights,t)}}export{j as B,q as G,z as O,N as a,U as e,S as r};
