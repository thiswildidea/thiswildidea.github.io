/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{getFilename as r,urlToObject as t}from"../core/urlUtils.js";import{p as a,e as s}from"./arcgisLayerUrl.js";import{f as o}from"./associatedFeatureServiceUtils.js";import{f as l}from"./fetchService.js";import{v as i}from"./layerUtils2.js";import{l as n}from"./lazyLayerLoader.js";import{f as c}from"./requestPresets.js";import"../core/lang.js";import"./typedArrayUtil.js";import"./Logger.js";import"../config.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./time.js";import"./persistableUrlUtils.js";import"../kernel.js";import"../request.js";import"../portal/Portal.js";import"../core/Loadable.js";import"../core/Promise.js";import"./reader.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./Ellipsoid.js";import"./assets.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./locale.js";import"../portal/PortalGroup.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalItem.js";import"../portal/PortalItemResource.js";import"../portal/PortalRating.js";const p={FeatureLayer:!0,SceneLayer:!0};async function u(n){const u=n.properties?.customParameters,d=await async function(n,u){let m=a(n);if(null==m&&(m=await async function(e,a){const o=await c(e,{customParameters:a});let l=null,i=null;const n=o.type;if("Feature Layer"===n||"Table"===n?(l="FeatureServer",i=o.id??null):"indexedVector"===n?l="VectorTileServer":o.hasOwnProperty("mapName")?l="MapServer":o.hasOwnProperty("bandCount")&&o.hasOwnProperty("pixelSizeX")?l="ImageServer":o.hasOwnProperty("maxRecordCount")&&o.hasOwnProperty("allowGeometryUpdates")?l="FeatureServer":o.hasOwnProperty("streamUrls")?l="StreamServer":y(o)?(l="SceneServer",i=o.id):o.hasOwnProperty("layers")&&y(o.layers?.[0])&&(l="SceneServer"),!l)return null;const p=null!=i?s(e):null;return{title:null!=p&&o.name||r(e),serverType:l,sublayer:i,url:{path:null!=p?p.serviceUrl:t(e).path}}}(n,u)),null==m)throw new e("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:n});const{serverType:d,sublayer:j}=m;let S;const v={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"},b="FeatureServer"===d,w="SceneServer"===d,h={parsedUrl:m,Constructor:null,layerId:b||w?j??void 0:void 0,layers:[],tables:[]};switch(d){case"MapServer":if(null!=j)S="FeatureLayer";else{const e=await async function(e,r){return(await c(e,{customParameters:r})).tileInfo}(n,u);S=e?"TileLayer":"MapImageLayer"}break;case"ImageServer":{const e=await c(n,{customParameters:u}),{tileInfo:r,cacheType:t}=e;S=r?"LERC"!==r?.format?.toUpperCase()||t&&"elevation"!==t.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await c(m.url.path,{customParameters:u});if(S="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)S="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=i[e]&&(S=i[e])}}break}case"FeatureServer":if(S="FeatureLayer",null!=j){const e=await c(n,{customParameters:u});h.sourceJSON=e,"Oriented Imagery Layer"===e.type&&(S="OrientedImageryLayer")}break;default:S=v[d]}if(p[S]&&null==j){const e=await async function(e,r,t){let a,s,i=!1;switch(r){case"FeatureServer":{const r=await l(e,{customParameters:t});i=!!r.layersJSON,a=r.layersJSON||r.serviceJSON;break}case"SceneServer":{const r=await async function(e,r){const t=await c(e,{customParameters:r}),a=t.layers?.[0];if(!a)return{serviceInfo:t};try{const{serverUrl:a}=await o(e),s=await c(a,{customParameters:r}).catch((()=>null));return s&&(t.tables=s.tables),{serviceInfo:t,tableServerUrl:a}}catch{return{serviceInfo:t}}}(e,t);a=r.serviceInfo,s=r.tableServerUrl;break}default:a=await c(e,{customParameters:t})}const n=a?.layers,p=a?.tables;return{layers:n?.map((e=>({id:e.id}))).reverse()||[],tables:p?.map((e=>({serverUrl:s,id:e.id}))).reverse()||[],layerInfos:i?n:[],tableInfos:i?p:[]}}(n,d,u);if(b&&(h.sublayerInfos=e.layerInfos,h.tableInfos=e.tableInfos),1!==e.layers.length+e.tables.length)h.layers=e.layers,h.tables=e.tables,b&&e.layerInfos?.length&&(h.sublayerConstructorProvider=await async function(e){const r=[],t=[];if(e.forEach((e=>{const{type:a}=e;"Oriented Imagery Layer"===a?(r.push(a),t.push(f("OrientedImageryLayer"))):(r.push(a),t.push(f("FeatureLayer")))})),!t.length)return;const a=await Promise.all(t),s=new Map;return r.forEach(((e,r)=>{s.set(e,a[r])})),e=>s.get(e.type)}(e.layerInfos));else if(b||w){const r=e.layerInfos?.[0]??e.tableInfos?.[0];h.layerId=e.layers[0]?.id??e.tables[0]?.id,h.sourceJSON=r,b&&"Oriented Imagery Layer"===r?.type&&(S="OrientedImageryLayer")}}return h.Constructor=await f(S),h}(n.url,u),j={...n.properties,url:n.url};if(d.layers.length+d.tables.length===0)return null!=d.layerId&&(j.layerId=d.layerId),null!=d.sourceJSON&&(j.sourceJSON=d.sourceJSON),new d.Constructor(j);const S=new(0,(await import("../layers/GroupLayer.js")).default)({title:d.parsedUrl.title});return await async function(e,r,t){function a(e,r,a,s){const o={...t,layerId:r,sublayerTitleMode:"service-name"};return null!=e&&(o.url=e),null!=a&&(o.sourceJSON=a),s(o)}const s=r.sublayerConstructorProvider;for(const{id:t,serverUrl:o}of r.layers){const l=m(r.sublayerInfos,t),i=(l&&s?.(l))??r.Constructor,n=a(o,t,l,(e=>new i(e)));e.add(n)}if(r.tables.length){const t=await f("FeatureLayer");r.tables.forEach((({id:s,serverUrl:o})=>{const l=a(o,s,m(r.tableInfos,s),(e=>new t(e)));e.tables.add(l)}))}}(S,d,j),S}function m(e,r){return e?e.find((e=>e.id===r)):null}function y(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function f(e){return(0,n[e])()}export{u as fromUrl};
