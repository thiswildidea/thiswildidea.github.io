/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import{throwIfAborted as e}from"../core/promiseUtils.js";import"./Logger.js";import"./ensureType.js";import"./typedArrayUtil.js";import"../core/Error.js";import{subclass as s}from"../core/accessorSupport/decorators/subclass.js";import{f as o,h as i,d as n}from"./vec3.js";import{c as r,a as d}from"./vec3f64.js";import{c,f as a,i as m}from"./lineSegment.js";import{c as p,b as u,n as h}from"./sphere.js";import{O as j}from"./Octree.js";import{e as l}from"./edgeProcessing.js";import"./handleUtils.js";import"./maybe.js";import"../core/lang.js";import"../config.js";import"./metadata.js";import"./utils.js";import"./tracking.js";import"./common.js";import"./mathUtils.js";import"./vector.js";import"./nextTick.js";import"./ByteSizeUnit.js";import"./mat3f64.js";import"./mat4f64.js";import"./quatf64.js";import"./vec2f64.js";import"./vec4f64.js";import"./mat4.js";import"./vec4.js";import"./Axis.js";import"./ObjectPool.js";import"./PooledArray.js";import"./frustum.js";import"./plane.js";import"./mathUtils2.js";import"./Util.js";import"./deduplicate.js";import"./Indices.js";import"./InterleavedLayout.js";import"./BufferView.js";import"./vec2.js";import"./types.js";import"./VertexAttribute.js";import"./glUtil.js";import"./enums3.js";import"./VertexElementDescriptor.js";function g(t,e,s){const r=p(),d=u(r);return o(d,d,t,.5),o(d,d,e,.5),r[3]=i(d,t),n(d,d,s),r}let f=class{constructor(){this._idToComponent=new Map,this._components=new j((t=>t.bounds)),this._edges=new j((t=>t.bounds)),this._tmpLineSegment=c(),this._tmpP1=r(),this._tmpP2=r(),this._tmpP3=r(),this.remoteClient=null}async fetchCandidates(t,s){await Promise.resolve(),e(s),await this._ensureEdgeLocations(t,s);const o=[];return this._edges.forEachNeighbor((e=>(this._addCandidates(t,e,o),o.length<1e3)),t.bounds),{result:{candidates:o}}}async _ensureEdgeLocations(t,e){const s=[];if(this._components.forEachNeighbor((t=>{if(null==t.info){const{id:e,uid:o}=t;s.push({id:e,uid:o})}return!0}),t.bounds),!s.length)return;const o={components:s},i=await this.remoteClient.invoke("fetchAllEdgeLocations",o,e??{});for(const t of i.components)this._setFetchEdgeLocations(t)}async add(t){const e=new b(t.id,t.bounds);return this._idToComponent.set(e.id,e),this._components.add([e]),{result:{}}}async remove(t){const e=this._idToComponent.get(t.id);if(e){const t=[];this._edges.forEachNeighbor((s=>(s.component===e&&t.push(s),!0)),e.bounds),this._edges.remove(t),this._components.remove([e]),this._idToComponent.delete(e.id)}return{result:{}}}_setFetchEdgeLocations(t){const e=this._idToComponent.get(t.id);if(null==e||t.uid!==e.uid)return;const s=l.createView(t.locations),o=new Array(s.count),i=r(),n=r();for(let r=0;r<s.count;r++){s.position0.getVec(r,i),s.position1.getVec(r,n);const d=g(i,n,t.origin),c=new y(e,r,d);o[r]=c}this._edges.add(o);const{objectIds:d,origin:c}=t;e.info={locations:s,objectIds:d,origin:c}}_addCandidates(t,e,s){const{info:o}=e.component,{origin:i,objectIds:r}=o,d=o.locations,c=d.position0.getVec(e.index,this._tmpP1),a=d.position1.getVec(e.index,this._tmpP2);n(c,c,i),n(a,a,i);const m=r[d.componentIndex.get(e.index)];this._addEdgeCandidate(t,m,c,a,s),this._addVertexCandidate(t,m,c,s),this._addVertexCandidate(t,m,a,s)}_addEdgeCandidate(t,e,s,o,n){if(!t.returnEdge)return;const r=u(t.bounds),c=a(s,o,this._tmpLineSegment),p=m(c,r,this._tmpP3);h(t.bounds,p)&&n.push({type:"edge",objectId:e,target:d(p),distance:i(r,p),start:d(s),end:d(o)})}_addVertexCandidate(t,e,s,o){if(!t.returnVertex)return;const n=u(t.bounds);h(t.bounds,s)&&o.push({type:"vertex",objectId:e,target:d(s),distance:i(n,s)})}};f=t([s("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],f);const _=f;class b{constructor(t,e){this.id=t,this.bounds=e,this.info=null,this.uid=++b.uid}}b.uid=0;class y{constructor(t,e,s){this.component=t,this.index=e,this.bounds=s}}export{_ as default};
