/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{d as t}from"./BufferView.js";import{S as e}from"./ShaderOutput.js";import{C as s}from"./basicInterfaces.js";import{G as r}from"./GLTextureMaterial.js";import{M as a}from"./Material.js";import{o as i,a as o,b as n,g as p,d as l}from"./OrderIndependentTransparency.js";import{R as u}from"./RenderSlot.js";import{a as c}from"./Util.js";import{V as h}from"./VertexAttribute.js";import{s as m,a as d,b as f,D as P,p as g,q as _}from"./DefaultBufferWriter.js";import{P as T}from"./DefaultLayouts.js";import{T as E}from"./TriangleMaterial.js";import{_ as I}from"./tslib.es6.js";import"./interfaces3.js";import{R as y,S as O,P as A}from"./Program2.js";import{p as S}from"./ShaderTechniqueConfiguration.js";import{T as v}from"./TransparencyPassType.js";import{D as b}from"./Texture2.js";import{I as j}from"./ImageMaterial.glsl.js";import{f as D}from"./enums3.js";import{b as x,m as R,c as N,d as w,a as C}from"./renderState2.js";class M extends O{initializeProgram(t){return new A(t.rctx,M.shader.get().build(this.configuration),F)}_setPipelineState(t,s){const r=this.configuration,a=t===v.NONE,l=t===v.FrontFace;return R({blending:r.output!==e.Color&&r.output!==e.Alpha||!r.transparent?null:a?L:i(t),culling:N(r.cullFace),depthTest:{func:o(t)},depthWrite:a?r.writeDepth?w:null:n(t),colorWrite:C,stencilWrite:r.hasOccludees?m:null,stencilTest:r.hasOccludees?s?d:f:null,polygonOffset:a||l?null:p(r.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._setPipelineState(this.configuration.transparencyPassType,!0),this._setPipelineState(this.configuration.transparencyPassType,!1)}getPipeline(t){return t?this._occludeePipelineState:super.getPipeline()}}M.shader=new y(j,(()=>import("./ImageMaterial.glsl.js").then((t=>t.I))));const L=x(D.ONE,D.ONE_MINUS_SRC_ALPHA);class V extends b{constructor(){super(...arguments),this.output=e.Color,this.cullFace=s.None,this.hasSlicePlane=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=v.NONE,this.multipassEnabled=!1,this.cullAboveGround=!1,this.perspectiveInterpolation=!0}}I([S({count:e.COUNT})],V.prototype,"output",void 0),I([S({count:s.COUNT})],V.prototype,"cullFace",void 0),I([S()],V.prototype,"hasSlicePlane",void 0),I([S()],V.prototype,"transparent",void 0),I([S()],V.prototype,"enableOffset",void 0),I([S()],V.prototype,"writeDepth",void 0),I([S()],V.prototype,"hasOccludees",void 0),I([S({count:v.COUNT})],V.prototype,"transparencyPassType",void 0),I([S()],V.prototype,"multipassEnabled",void 0),I([S()],V.prototype,"cullAboveGround",void 0),I([S()],V.prototype,"perspectiveInterpolation",void 0),I([S({constValue:!1})],V.prototype,"occlusionPass",void 0);const F=new Map([[h.POSITION,0],[h.UV0,2],[h.PERSPECTIVEDIVIDE,3]]);class U extends E{constructor(t){super(t,new W),this.supportsEdges=!0,this._vertexAttributeLocations=F,this._configuration=new V}getConfiguration(t,e){return this._configuration.output=t,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=e.transparencyPassType,this._configuration.enableOffset=e.camera.relativeElevation<l,this._configuration.multipassEnabled=e.multipassEnabled,this._configuration.cullAboveGround=e.multipassTerrain.cullAboveGround,this._configuration.perspectiveInterpolation=this.parameters.perspectiveInterpolation,this._configuration}produces(t,s){return!(s!==e.Color&&s!==e.Alpha&&s!==e.Highlight||t!==u.DRAPED_MATERIAL&&(s===e.Highlight?t!==u.OPAQUE_MATERIAL:t!==(this.parameters.transparent?this.parameters.writeDepth?u.TRANSPARENT_MATERIAL:u.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:u.OPAQUE_MATERIAL)))}createGLMaterial(t){return new G(t)}createBufferWriter(){const t=T.clone();return this.parameters.perspectiveInterpolation&&t.f32(h.PERSPECTIVEDIVIDE),new B(t)}}class G extends r{constructor(t){super({...t,...t.material.parameters})}_updateParameters(t){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.ensureTechnique(M,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.hasOccludees&&(this._material.setParameters({hasOccludees:t.hasOccludees}),this._updateParameters(t))}beginSlot(t){return this._output!==e.Color&&this._output!==e.Alpha||this._updateOccludeeState(t),this._updateParameters(t)}}class B extends P{write(e,s,r,a,i){for(const o of this.vertexBufferLayout.fields.keys()){const n=r.attributes.get(o);if(n)if(o===h.PERSPECTIVEDIVIDE){c(1===n.size);const e=a.getField(o,t);e&&g(n,e,i)}else _(o,n,e,s,a,i)}}}class W extends a{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.hasSlicePlane=!1,this.cullFace=s.None,this.hasOccludees=!1,this.opacity=1,this.textureId=null,this.initTextureTransparent=!0,this.perspectiveInterpolation=!1}}export{U as I};
