/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{E as e,i as r}from"./typedArrayUtil.js";import t from"../core/Error.js";import{u as a}from"./originUtils.js";import{s as o,g as s,a as i,b as l,c as n,d as p,e as m,f as c,h as u}from"./utils20.js";import{p as y}from"./arcgisLayerUrl.js";import{f}from"./fetchService.js";import{w as d}from"./layerUtils2.js";import{l as j}from"./lazyLayerLoader.js";import{a as h}from"./jsonContext.js";import{a as w,r as g,T as v,t as P,b}from"./portalItemUtils.js";import"../core/lang.js";import"./Logger.js";import"../config.js";import"./multiOriginJSONSupportUtils.js";import"../portal/Portal.js";import"./tslib.es6.js";import"../kernel.js";import"../core/urlUtils.js";import"../core/JSONSupport.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"../core/promiseUtils.js";import"./time.js";import"../request.js";import"../core/Loadable.js";import"../core/Promise.js";import"./reader.js";import"../geometry/Extent.js";import"../geometry/Geometry.js";import"../geometry/SpatialReference.js";import"./unitUtils.js";import"./jsonMap.js";import"./Ellipsoid.js";import"./assets.js";import"./writer.js";import"../geometry/Point.js";import"../core/accessorSupport/decorators/cast.js";import"../geometry/support/webMercatorUtils.js";import"./locale.js";import"../portal/PortalGroup.js";import"../portal/PortalQueryParams.js";import"../portal/PortalQueryResult.js";import"../portal/PortalUser.js";import"../portal/PortalFolder.js";import"../portal/PortalItem.js";import"../portal/PortalItemResource.js";import"../portal/PortalRating.js";import"./saveAPIKeyUtils.js";import"./persistableUrlUtils.js";import"./requestPresets.js";import"../geometry/projection.js";import"./SimpleObservable.js";import"./vec3f64.js";import"../geometry/Multipoint.js";import"./zmUtils.js";import"../geometry/Polygon.js";import"./Axis.js";import"./extentUtils.js";import"./aaBoundingRect.js";import"./mathUtils.js";import"./vec3.js";import"./common.js";import"../geometry/Polyline.js";import"./projectBuffer.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/support/GeographicTransformationStep.js";import"./zscale.js";const S="Feature Service",T="feature-layer-utils",I=`${T}-save`,L=`${T}-save-as`,U=`${T}-saveall`,E=`${T}-saveall-as`;function A(e){return{isValid:d(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function x(e){const r=[],t=[];for(const{layer:a,layerJSON:o}of e)a.isTable?t.push(o):r.push(o);return{layers:r,tables:t}}function O(e){return x([e])}async function N(e,r){return/\/\d+\/?$/.test(e.url)?O(r[0]):$(r,e)}async function $(e,r){if(!r)return e.reverse(),x(e);const{layer:{url:t,customParameters:a,apiKey:o}}=e[0];let s=await r.fetchData("json");null!=s?.layers&&null!=s?.tables||(s=await async function(e,r,t){e||={},e.layers||=[],e.tables||=[];const{url:a,customParameters:o,apiKey:s}=r,{serviceJSON:i,layersJSON:l}=await f(a,{customParameters:o,apiKey:s}),n=R(e.layers,i.layers,t),p=R(e.tables,i.tables,t);e.layers=n.itemResources,e.tables=p.itemResources;const m=[...n.added,...p.added],c=l?[...l.layers,...l.tables]:[];return await async function(e,r,t,a){const o=await async function(e){const r=[];e.forEach((({type:e})=>{const t=function(e){let r;switch(e){case"Feature Layer":case"Table":r="FeatureLayer";break;case"Oriented Imagery Layer":r="OrientedImageryLayer"}return r}(e),a=j[t];r.push(a())}));const t=await Promise.all(r),a=new Map;return e.forEach((({type:e},r)=>{a.set(e,t[r])})),a}(r),s=r.map((({id:e,type:r})=>new(o.get(r))({url:t,layerId:e,sourceJSON:a.find((({id:r})=>r===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((r=>{const{layerId:t,loaded:a,defaultPopupTemplate:o}=r;if(!a||null==o)return;const s={id:t,popupInfo:o.toJSON()};"ArcGISFeatureLayer"!==r.operationalLayerType&&(s.layerType=r.operationalLayerType),M(r,s,e)}))}(e,m,a,c),e}(s,{url:t??"",customParameters:a,apiKey:o},e.map((e=>e.layer.layerId))));for(const r of e)M(r.layer,r.layerJSON,s);return s}function R(r,t,a){const o=e(r,t,((e,r)=>e.id===r.id));r=r.filter((e=>!o.removed.some((r=>r.id===e.id))));const s=o.added;return s.forEach((({id:e})=>{r.push({id:e})})),{itemResources:r,added:s.filter((({id:e})=>!a.includes(e)))}}function M(e,r,t){e.isTable?J(t.tables,r):J(t.layers,r)}function J(e,r){const t=e.findIndex((({id:e})=>e===r.id));-1===t?e.push(r):e[t]=r}function F(e,r){if(!e.length)throw new t(`${r}:missing-parameters`,"'layers' array should contain at least one feature layer")}function G(e,r){const a=e.map((e=>e.layerId));if(new Set(a).size!==a.length)throw new t(`${r}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function D(e,r){const{url:t,layerId:a,title:o,fullExtent:s,isTable:i}=e,l=y(t);r.url="FeatureServer"===l?.serverType?t:`${t}/${a}`,r.title||=o,r.extent=null,i||null==s||(r.extent=await w(s)),g(r,v.METADATA),g(r,v.MULTI_LAYER),b(r,v.SINGLE_LAYER),i&&b(r,v.TABLE)}async function z(e,r){return o({layer:e,itemType:S,validateLayer:A,createItemData:(e,r)=>N(r,[e]),errorNamePrefix:I},r)}async function B(e,r){await async function(e){F(e,U),await Promise.all(e.map((e=>e.load())));for(const r of e)m(r,U,A),c({layer:r,itemType:S,errorNamePrefix:U});!function(e,r){const a=e.map((e=>e.portalItem.id));if(new Set(a).size>1)throw new t(`${r}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}(e,U),G(e,U)}(e);const o=e[0].portalItem,l=h(o),n=await Promise.all(e.map((e=>s(e,l,r)))),p=await N(o,e.map(((e,r)=>({layer:e,layerJSON:n[r]}))));return i(o),await o.update({data:p}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),a(l),o.clone()}async function K(e,r,t){return l({layer:e,itemType:S,validateLayer:A,createItemData:(e,r)=>Promise.resolve(O(e)),errorNamePrefix:L,newItem:r,setItemProperties:D},t)}async function k(e,o,l){await async function(e){F(e,E),await Promise.all(e.map((e=>e.load())));for(const r of e)m(r,E,A);!function(e,r){for(const a of e){const o=a.parsedUrl.path,s=y(o),i=s?.url.path;if(!i)throw new t(`${r}:invalid-parameters`,u(a,`has unsupported url pattern: ${o}`),{layer:a});const l=s?.serverType;if("FeatureServer"!==l&&"MapServer"!==l)throw new t(`${r}:invalid-parameters`,u(a,`has unsupported server type: ${l}`),{layer:a});if("MapServer"===l&&e.length>1)throw new t(`${r}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const a=y(e[0].parsedUrl.path),o=a?.url.path,s=e.every((e=>{const r=y(e.parsedUrl.path);return r?.url.path===o}));if(!s)throw new t(`${r}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}(e,E),G(e,E)}(e);const c=n({itemType:S,errorNamePrefix:E,newItem:o}),f=h(c),d=await Promise.all(e.map((e=>s(e,f,l)))),j=await $(e.map(((e,r)=>({layer:e,layerJSON:d[r]}))));await async function(e,t){let a=0,o=0;for(const{isTable:e}of t)e?o++:a++;const s=t[0].parsedUrl.path,l=y(s);if(e.url="FeatureServer"===l?.serverType?l.url.path:s,e.title||=l.title,e.extent=null,a>0){const a=t.map((e=>e.fullExtent)).filter(r).reduce(((e,r)=>e.clone().union(r)));a&&(e.extent=await w(a))}g(e,v.METADATA),P(e,v.MULTI_LAYER,t.length>1),P(e,v.SINGLE_LAYER,1===t.length),P(e,v.TABLE,o>0&&0===a),i(e)}(c,e),await p(c,j,l);for(const r of e)r.portalItem=c.clone();return a(f),c}export{z as save,B as saveAll,k as saveAllAs,K as saveAs};
