/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import e from"../core/Error.js";import{L as t}from"./Logger.js";import{a as r}from"./Util.js";var n;!function(e){e[e.Pass=0]="Pass",e[e.Draw=1]="Draw"}(n||(n={}));class s{constructor(e,t,r,s,i=null){if(this.name=e,this.type=t,this.arraySize=i,this.bind={[n.Pass]:null,[n.Draw]:null},s)switch(r){case n.Pass:this.bind[n.Pass]=s;break;case n.Draw:this.bind[n.Draw]=s}}equals(e){return this.type===e.type&&this.name===e.name&&this.arraySize===e.arraySize}}const i=t.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class a{constructor(){this._includedModules=new Map}include(e,t){if(this._includedModules.has(e)){const r=this._includedModules.get(e);if(r!==t){i.error("Trying to include shader module multiple times with different sets of options.");const t=new Set;for(const n of Object.keys(r))r[n]!==e[n]&&t.add(n);for(const n of Object.keys(e))r[n]!==e[n]&&t.add(n);t.forEach((t=>console.error(`  ${t}: current ${r[t]} new ${e[t]}`)))}}else this._includedModules.set(e,t),e(this.builder,t)}}class o extends a{constructor(){super(...arguments),this.vertex=new h,this.fragment=new h,this.attributes=new m,this.varyings=new l,this.extensions=new d,this.constants=new f,this.outputs=new _}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e){const t=this.extensions.generateSource(e),r=this.attributes.generateSource(e),n=this.varyings.generateSource(e),s="vertex"===e?this.vertex:this.fragment,i=s.uniforms.generateSource(),a=s.code.generateSource(),o="vertex"===e?S:g,c=this.constants.generateSource().concat(s.constants.generateSource()),u=this.outputs.generateSource(e);return`#version 300 es\n${t.join("\n")}\n\n${o}\n\n${c.join("\n")}\n\n${i.join("\n")}\n\n${r.join("\n")}\n\n${n.join("\n")}\n\n${u.join("\n")}\n\n${a.join("\n")}`}generateBindPass(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[n.Pass];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[n.Pass];r&&t.set(e.name,r)}));const r=Array.from(t.values()),s=r.length;return(t,n)=>{for(let i=0;i<s;++i)r[i](e,t,n)}}generateBindDraw(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[n.Draw];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[n.Draw];r&&t.set(e.name,r)}));const r=Array.from(t.values()),s=r.length;return(t,n,i)=>{for(let a=0;a<s;++a)r[a](e,t,n,i)}}}class c{constructor(){this._entries=new Map}add(...e){for(const t of e)this._add(t)}get(e){return this._entries.get(e)}_add(t){if(null!=t){if(this._entries.has(t.name)&&!this._entries.get(t.name).equals(t))throw new e(`Duplicate uniform name ${t.name} for different uniform type`);this._entries.set(t.name,t)}else i.error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map((e=>null!=e.arraySize?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class u{constructor(){this._entries=new Array}add(e){this._entries.push(e)}generateSource(){return this._entries}}class h extends a{constructor(){super(...arguments),this.uniforms=new c,this.code=new u,this.constants=new f}get builder(){return this}}class m{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`in ${e[1]} ${e[0]};`))}}class l{constructor(){this._entries=new Map}add(e,t){this._entries.has(e)&&r(this._entries.get(e)===t),this._entries.set(e,t)}generateSource(e){const t=new Array;return this._entries.forEach(((r,n)=>t.push("vertex"===e?`out ${r} ${n};`:`in ${r} ${n};`))),t}}class d{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?d.ALLOWLIST_VERTEX:d.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}d.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],d.ALLOWLIST_VERTEX=[];class _{constructor(){this._entries=new Map}add(e,t,n=0){const s=this._entries.get(n);s?r(s.name===e&&s.type===t,`Fragment shader output location ${n} occupied`):this._entries.set(n,{name:e,type:t})}generateSource(e){if("vertex"===e)return[];0===this._entries.size&&this._entries.set(0,{name:_.DEFAULT_NAME,type:_.DEFAULT_TYPE});const t=new Array;return this._entries.forEach(((e,r)=>t.push(`layout(location = ${r}) out ${e.type} ${e.name};`))),t}}_.DEFAULT_TYPE="vec4",_.DEFAULT_NAME="fragColor";class f{constructor(){this._entries=new Set}add(e,t,r){let n="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":n=f._numberToFloatStr(r);break;case"int":n=f._numberToIntStr(r);break;case"bool":n=r.toString();break;case"vec2":n=`vec2(${f._numberToFloatStr(r[0])},                            ${f._numberToFloatStr(r[1])})`;break;case"vec3":n=`vec3(${f._numberToFloatStr(r[0])},                            ${f._numberToFloatStr(r[1])},                            ${f._numberToFloatStr(r[2])})`;break;case"vec4":n=`vec4(${f._numberToFloatStr(r[0])},                            ${f._numberToFloatStr(r[1])},                            ${f._numberToFloatStr(r[2])},                            ${f._numberToFloatStr(r[3])})`;break;case"ivec2":n=`ivec2(${f._numberToIntStr(r[0])},                             ${f._numberToIntStr(r[1])})`;break;case"ivec3":n=`ivec3(${f._numberToIntStr(r[0])},                             ${f._numberToIntStr(r[1])},                             ${f._numberToIntStr(r[2])})`;break;case"ivec4":n=`ivec4(${f._numberToIntStr(r[0])},                             ${f._numberToIntStr(r[1])},                             ${f._numberToIntStr(r[2])},                             ${f._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":n=`${t}(${Array.prototype.map.call(r,(e=>f._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${n};`),this}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const g="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif",S="precision highp float;\nprecision highp sampler2D;";export{n as B,o as S,s as U};
