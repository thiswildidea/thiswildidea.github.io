/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import t from"../core/Accessor.js";import i from"../core/Evented.js";import{clone as n}from"../core/lang.js";import{d as s,e as o}from"./maybe.js";import{ignoreAbortErrors as r}from"../core/promiseUtils.js";import{watch as a,syncAndInitial as p}from"../core/reactiveUtils.js";import{c,a as l}from"./screenUtils.js";import{property as h}from"../core/accessorSupport/decorators/property.js";import"./ensureType.js";import{subclass as d}from"../core/accessorSupport/decorators/subclass.js";import{d as u}from"./diffUtils.js";import{U as g}from"./UpdatingHandles.js";import{p as m}from"./dehydratedFeatureComparison.js";import{m as v,c as y,k as _}from"./elevationInfoUtils.js";import{V as f}from"./ViewingMode.js";import{c as x,E as S,a as w,C as V}from"./EditGeometryOperations.js";import{c as b,s as T}from"./dragEventPipeline.js";import{s as O,h as M,t as C}from"./snappingUtils.js";import I from"../views/interactive/sketch/SketchLabelOptions.js";import P from"../views/interactive/sketch/SketchTooltipOptions.js";import{S as D}from"./SnappingContext.js";import{c as E}from"./SnappingDragPipelineStep.js";import{S as H}from"./SnappingOperation.js";import{m as k}from"./dehydratedPoint.js";import{c as j}from"./hydratedFeatures.js";const Z=["freehand","hybrid","click"],G="click";class z{constructor({grabbableForEvent:e}){this.events=new i,this.interactive=!0,this.selectable=!1,this.cursor=null,this.grabbable=!0,this.consumesClicks=!0,this.grabbableForEvent=e}destroy(){}intersectionDistance(e,t){return 0}attach(){}detach(){}onElevationChange(){}onViewChange(){}}let F=class extends(i.EventedMixin(t)){constructor(e){super(e),this._createOperationCompleted=!1,this._hideDefaultCursor=!1,this._pointerDownStates=new Set,this._stagedScreenPoint=null,this._stagedPointerType=null,this._stagedPointerId=null,this._updatingHandles=new g,this.constraint=void 0,this.isDraped=!0,this.labelOptions=new I,this.tooltipOptions=new P,this.cursor=null,this.loading=!1,this.snapToSceneEnabled=null,this.lastVertex=null,null==e.elevationInfo&&(this.elevationInfo=v(!!e.hasZ))}initialize(){const{geometryType:e,view:t}=this,i=t.spatialReference,n="viewingMode"in t.state?t.state.viewingMode:f.Local,s="segment"===e||"multipoint"===e?"polyline":e;this.coordinateHelper=x(this.hasZ,this.hasM,i),this._editGeometryOperations=new S(new w(s,this.coordinateHelper)),this._snappingOperation=new H({view:t,constrainResult:e=>e?this._getEffectiveDrawSurface()?.constrainZ(e):void 0}),this.addHandles([a((()=>this.stagedVertex),(e=>{null!=e&&this.emit("cursor-update",{updated:null,vertices:[{componentIndex:0,vertexIndex:this._activeComponent.vertices.length,coordinates:this.coordinateHelper.pointToArray(e)}],operation:"apply",type:"vertex-update"})}),{sync:!0,equals:(e,t)=>o(e,t,m)}),a((()=>this.view.viewpoint),((e,t)=>{e&&t&&u(e,t)&&this._onViewpointChange()}))]),this._activeComponent=new V(i,n),this._editGeometryOperations.data.components.push(this._activeComponent);const c=this.segmentLabels;null!=c&&(c.context={view:t,editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,labelOptions:this.labelOptions},this.addHandles([a((()=>this.labelOptions.enabled),(e=>{c.visible=e}),p),this.on("cursor-update",(()=>{const e=this.stagedVertex;c.stagedVertex=null!=e?this.coordinateHelper.pointToVector(e):null}))])),this.addHandles(this._editGeometryOperations.on(["vertex-add","vertex-update","vertex-remove"],(e=>{const t=e.vertices.map((e=>({componentIndex:0,vertexIndex:e.index,coordinates:this.coordinateHelper.vectorToArray(e.pos)}))),i=t.map((e=>e.coordinates));switch(e.type){case"vertex-add":this.emit(e.type,{...e,added:i,vertices:t});break;case"vertex-update":this.emit(e.type,{...e,updated:i,vertices:t});break;case"vertex-remove":this.emit(e.type,{...e,removed:i,vertices:t})}const n=this._activeComponent.getLastVertex(),s=null!=n?this.coordinateHelper.vectorToDehydratedPoint(n.pos):null;null!=s&&null!=this.lastVertex&&m(this.lastVertex,s)||(this.lastVertex=s)})));const l=this._manipulator=new z({grabbableForEvent:e=>"click"!==this.drawingMode||"touch"===e.pointerType&&this._snappingEnabled&&1===this._pointerDownStates.size});this.manipulators.add(l),l.grabbable="point"!==e,this.addHandles([this._createManipulatorDragPipeline(l),l.events.on("immediate-click",(e=>this._onImmediateClick(e))),l.events.on("immediate-double-click",(e=>this._onImmediateDoubleClick(e))),a((()=>({effectiveCursor:this.effectiveCursor})),(({effectiveCursor:e})=>{l.cursor=e}),p)]),O(this,(()=>{const e=this.view.inputManager.latestPointerType??"mouse",t=this._getSnappingContext(e);null!=this.snappingManager&&this._updatingHandles.addPromise(r(this._snappingOperation.resnap(this.snappingManager,t)))}))}destroy(){s(this.segmentLabels),s(this._snappingOperation),this._editGeometryOperations=s(this._editGeometryOperations),this._updatingHandles.destroy()}get _snappingEnabled(){return null!=this.snappingManager&&this.snappingManager.options.effectiveEnabled}get _requiresScenePoint(){const e=this._getEffectiveDrawSurface();return"3d"===this.view.type&&this.drawSurface!==e}get canRedo(){return this._editGeometryOperations.canRedo}get canUndo(){return this._editGeometryOperations.canUndo}get committedVertices(){return this._activeComponent.vertices.map((e=>this.coordinateHelper.vectorToArray(e.pos)))}set drawingMode(e){this._set("drawingMode",e??G)}get effectiveCursor(){return this.loading?"progress":this._hideDefaultCursor?null:this.cursor||"crosshair"}get interactive(){return this._manipulator.interactive}set interactive(e){this._manipulator.interactive=e}get isCompleted(){return this._createOperationCompleted}get numCommittedVertices(){return this._activeComponent.vertices.length}get numVertices(){return null!=this.stagedVertex?this._activeComponent.vertices.length+1:this._activeComponent.vertices.length}get snappingOptions(){return null!=this.snappingManager?this.snappingManager.options:null}get stagedVertex(){const e=this._snappingOperation.stagedPoint,{constraint:t,elevationInfo:i,view:n}=this;if(!e||!t)return e;const s=M(e,n,i),o=s?t.closestTo(s):void 0;return o?C(o,e.spatialReference):e}set stagedVertex(e){this._snappingOperation.stagedPoint=n(e)}get updating(){return this._updatingHandles.updating}get vertices(){const e=this.committedVertices;return null!=this.stagedVertex&&e.push(this.coordinateHelper.pointToArray(this.stagedVertex)),e}cancel(){this.complete({aborted:!0})}commitStagedVertex(){if(this._snappingOperation.abort(),null!=this.stagedVertex){const{stagedVertex:e}=this;this.stagedVertex=null,this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(e))}}complete(e){const t=e&&e.aborted||!1;this._snappingOperation.abort(),null!=this.snappingManager&&this.snappingManager.doneSnapping(),"segment"===this.geometryType||"point"===this.geometryType?this.commitStagedVertex():this.stagedVertex=null;const i="multipoint"===this.geometryType&&0===this.numVertices||"polyline"===this.geometryType&&this.numVertices<2||"polygon"===this.geometryType&&this.numVertices<3;this._createOperationCompleted=!i,(this.isCompleted||t)&&this.emit("complete",{vertices:this.vertices.map(((e,t)=>({componentIndex:0,vertexIndex:t,coordinates:e}))),aborted:t,type:"complete"})}onInputEvent(e){switch(e.type){case"pointer-down":this._pointerDownStates.add(e.pointerId);break;case"pointer-up":this._pointerDownStates.delete(e.pointerId)}switch(e.type){case"pointer-move":return this._onPointerMove(e);case"hold":return this._onHold(e)}}redo(){this._editGeometryOperations.redo()}undo(){null!=this.snappingManager&&this.snappingManager.doneSnapping(),this._editGeometryOperations.undo()}_closeOnClickVertexIndex(e){const t=this._activeComponent;if("polygon"===this.geometryType&&t.vertices.length>2){if(this._vertexWithinPointerDistance(t.vertices[0].pos,e))return 0;if(this._vertexWithinPointerDistance(t.vertices[t.vertices.length-1].pos,e))return t.vertices.length-1}return null}_createManipulatorDragPipeline(e){switch(this.drawingMode){case"click":return this._createManipulatorDragPipelineClick(e);case"freehand":return this._createManipulatorDragPipelineFreehand(e);case"hybrid":return this._createManipulatorDragPipelineHybrid(e)}}_createManipulatorDragPipelineClick(e){return b(e,((e,t,i,n)=>{const s="touch"===n&&this._snappingEnabled;if(this.isCompleted||!s)return;const{snappingStep:o,cancelSnapping:r}=E({predicate:()=>s,snappingManager:this.snappingManager,snappingContext:new D({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,feature:this.graphic,pointer:n,visualizer:this.snappingVisualizer}),updatingHandles:this._updatingHandles,useZ:!this._requiresScenePoint});i=i.next((e=>(s&&null!=this.snappingManager&&this.snappingManager.doneSnapping(),e))).next(r),t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(this.stagedVertex=e.mapStart,("segment"===this.geometryType||s&&0===this.numVertices)&&this.commitStagedVertex()),e))).next(T(this.view,this.elevationInfo)).next(...o).next((e=>(s&&(this.stagedVertex=e.mapEnd,"end"===e.action&&this.commitStagedVertex()),e))).next((e=>("end"===e.action&&("segment"!==this.geometryType&&"point"!==this.geometryType||this.complete()),e)))}))}_createManipulatorDragPipelineFreehand(e){return b(e,((e,t)=>{this.isCompleted||t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(null==this.stagedVertex&&(this.stagedVertex=e.mapStart),"segment"===this.geometryType&&this.commitStagedVertex()),e))).next((e=>{switch(e.action){case"start":case"update":this.stagedVertex=e.mapEnd,"polygon"!==this.geometryType&&"polyline"!==this.geometryType||this.commitStagedVertex();break;case"end":this.complete()}return e}))}))}_createManipulatorDragPipelineHybrid(e){return b(e,((e,t)=>{this.isCompleted||t.next(this._screenToMapDragEventStep()).next((e=>("start"===e.action&&(null==this.stagedVertex&&(this.stagedVertex=e.mapStart),this.commitStagedVertex()),e))).next((e=>{switch(e.action){case"start":case"update":this.stagedVertex=e.mapEnd,"polygon"!==this.geometryType&&"polyline"!==this.geometryType||this.commitStagedVertex();break;case"end":"segment"!==this.geometryType&&"point"!==this.geometryType||this.complete()}return e}))}))}get _drawAtFixedElevation(){return("segment"===this.geometryType||"polygon"===this.geometryType)&&this.numCommittedVertices>0}_getEffectiveDrawSurface(){if(null==this.elevationDrawSurface)return this.drawSurface;if(!this.coordinateHelper.hasZ())return this.elevationDrawSurface.defaultZ=null,this.elevationDrawSurface;let e=this.defaultZ,t=!1;return null!=this.elevationInfo&&"absolute-height"===this.elevationInfo.mode&&(t=!0),null!=this.snapToSceneEnabled&&(t=this.snapToSceneEnabled),null!=this.elevationInfo&&"on-the-ground"===this.elevationInfo.mode&&(t=!1),this._drawAtFixedElevation&&(e=this.coordinateHelper.getZ(this._activeComponent.vertices[0].pos),t=!1),t?this.drawSurface:(this.elevationDrawSurface.defaultZ=e,this.elevationDrawSurface)}_mapToScreen(e){return this._getEffectiveDrawSurface()?.mapToScreen(e)}_onHold(e){this._snappingOperation.abort(),"click"===this.drawingMode&&"touch"===e.pointerType&&this._snappingEnabled&&(this.stagedVertex=e.mapPoint),e.stopPropagation()}_onImmediateClick(e){if("mouse"===e.pointerType&&2===e.button||this._manipulator.dragging)return;const t=this._activeComponent;if(null!=this._closeOnClickVertexIndex(e.screenPoint))return e.stopPropagation(),void this.complete();const i=this._screenToMap(e.screenPoint);if(null!=i)switch(this.drawingMode){case"freehand":"point"===this.geometryType&&(null!=this.stagedVertex?this.commitStagedVertex():this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(i)),this.complete());break;case"click":case"hybrid":this._snappingOperation.abort(),null!=this.stagedVertex?this.commitStagedVertex():this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(i)),("point"===this.geometryType||"segment"===this.geometryType&&2===t.vertices.length||"segment"===this.geometryType&&"hybrid"===this.drawingMode&&1===t.vertices.length)&&this.complete()}e.stopPropagation()}_onImmediateDoubleClick(e){this._manipulator.dragging||"point"===this.geometryType||(this.complete(),e.stopPropagation())}_onPointerMove(e){const t=c(e.x,e.y);this._stagedScreenPoint=t,this._stagedPointerType=e.pointerType,this._stagedPointerId=e.pointerId;const i=this._snappingOperation,n=this._manipulator;this._pointerDownStates.has(e.pointerId)||n.grabbing||!n.interactive?i.abort():(e.stopPropagation(),this._updateStagedVertexOnPointerMove(t,e.pointerType))}_onViewpointChange(){const e=this._manipulator;"mouse"===this._stagedPointerType&&this._stagedScreenPoint&&null!=this._stagedPointerId&&!this._pointerDownStates.has(this._stagedPointerId)&&!e.grabbing&&e.interactive?this._updateStagedVertexOnPointerMove(this._stagedScreenPoint,this._stagedPointerType??"mouse"):this._snappingOperation.abort()}_updateStagedVertexOnPointerMove(e,t){const i=this._snappingOperation,n=this._closeOnClickVertexIndex(e);if(null!=n)return this._closeOnVertex(n),void i.abort();const s=this._screenToMap(e),o=this._requiresScenePoint?this.drawSurface?.screenToMap(e):null;if(null==s)return this._hideDefaultCursor=!0,void i.abort();this._hideDefaultCursor=!1;const a=this.snappingManager;if(null==a)return this.stagedVertex=s,void i.abort();const p=this._getSnappingContext(t);this._updatingHandles.addPromise(r(i.snap({point:s,scenePoint:o},a,p)))}_closeOnVertex(e){this.stagedVertex=null;const t={componentIndex:0,vertexIndex:e,coordinates:this.coordinateHelper.vectorToArray(this._activeComponent.vertices[e].pos)};this.emit("cursor-update",{updated:null,vertices:[t],operation:"apply",type:"vertex-update"})}_screenToMap(e){return this._getEffectiveDrawSurface()?.screenToMap(e)}_screenToMapDragEventStep(){let e=null;return t=>{if("start"===t.action&&(e=this._screenToMap(t.screenStart)),null==e)return null;const i=this._screenToMap(t.screenEnd);return null!=i?{...t,mapStart:e,mapEnd:i}:null}}_vertexWithinPointerDistance(e,t){const i=this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(e));return null!=i&&function(e,t,i){const n=e.x-t.x,s=e.y-t.y;return n*n+s*s<=25}(i,t)}_getSnappingContext(e){const t=this._drawAtFixedElevation?this.elevationDrawSurface?.defaultZ:null;return new D({editGeometryOperations:this._editGeometryOperations,elevationInfo:this.elevationInfo,pointer:e,feature:this.graphic,visualizer:this.snappingVisualizer,selfSnappingZ:null!=t?{value:t,elevationInfo:this.elevationInfo}:null})}};e([h()],F.prototype,"_hideDefaultCursor",void 0),e([h()],F.prototype,"_snappingOperation",void 0),e([h()],F.prototype,"_snappingEnabled",null),e([h({constructOnly:!0})],F.prototype,"graphic",void 0),e([h()],F.prototype,"constraint",void 0),e([h()],F.prototype,"defaultZ",void 0),e([h()],F.prototype,"isDraped",void 0),e([h({value:G})],F.prototype,"drawingMode",null),e([h({constructOnly:!0})],F.prototype,"elevationDrawSurface",void 0),e([h({constructOnly:!0})],F.prototype,"elevationInfo",void 0),e([h({constructOnly:!0,type:I})],F.prototype,"labelOptions",void 0),e([h({constructOnly:!0,type:P})],F.prototype,"tooltipOptions",void 0),e([h({constructOnly:!0})],F.prototype,"geometryType",void 0),e([h({constructOnly:!0})],F.prototype,"hasM",void 0),e([h({constructOnly:!0})],F.prototype,"hasZ",void 0),e([h()],F.prototype,"cursor",void 0),e([h()],F.prototype,"effectiveCursor",null),e([h()],F.prototype,"loading",void 0),e([h({constructOnly:!0})],F.prototype,"manipulators",void 0),e([h({constructOnly:!0})],F.prototype,"drawSurface",void 0),e([h({constructOnly:!0})],F.prototype,"segmentLabels",void 0),e([h({constructOnly:!0})],F.prototype,"snappingManager",void 0),e([h({constructOnly:!0})],F.prototype,"snappingVisualizer",void 0),e([h()],F.prototype,"snapToSceneEnabled",void 0),e([h()],F.prototype,"stagedVertex",null),e([h()],F.prototype,"lastVertex",void 0),e([h()],F.prototype,"updating",null),e([h({constructOnly:!0})],F.prototype,"view",void 0),F=e([d("esri.views.draw.DrawOperation")],F);class U{constructor(e,t,i,n=null){this._elevationInfo=e,this.defaultZ=t,this._view=i,this._excludeGraphics=n}screenToMap(e){if(null!=this.defaultZ)return this._view.sceneIntersectionHelper.intersectElevationFromScreen(l(e.x,e.y),this._elevationInfo,this.defaultZ,this._excludeGraphics);const t=this._view.sceneIntersectionHelper.intersectElevationFromScreen(l(e.x,e.y),this._elevationInfo,0,this._excludeGraphics);return null!=t&&(t.z=void 0),t}mapToScreen(e){const t=k(e.x,e.y,y(this._view,e,this._elevationInfo),e.spatialReference);return this._view.toScreen(t)}constrainZ(e){const{defaultZ:t}=this;return null!=t&&e.z!==t&&((e=j(e)).z=t),e}}class A{constructor(e,t,i=[]){this.view=e,this.elevationInfo=t,this.exclude=i}screenToMap(e){const t=this.view.toMap(e,{exclude:this.exclude});return null!=t&&(t.z=_(t,this.view,this.elevationInfo)),t}mapToScreen(e){let t=e;return null!=this.elevationInfo&&(t=k(e.x,e.y,y(this.view,e,this.elevationInfo),e.spatialReference)),this.view.toScreen(t)}constrainZ(e){return e}}class R{constructor(e,t=!1,i=0){this.view=e,this.hasZ=t,this.defaultZ=i,this.mapToScreen=t=>e.toScreen(t),this.screenToMap=t?t=>{const n=e.toMap(t);return n.z=i,n}:t=>e.toMap(t)}constrainZ(e){const{defaultZ:t}=this;return this.hasZ&&e.z!==t&&((e=j(e)).z=t),e}}export{F as D,U as E,R as M,A as S,Z as a,G as d};
