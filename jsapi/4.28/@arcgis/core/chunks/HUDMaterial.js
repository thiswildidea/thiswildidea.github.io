/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{h as e}from"./typedArrayUtil.js";import{c as t}from"./mathUtils.js";import{f as s}from"./mat3.js";import{a as i}from"./mat3f64.js";import{i as r}from"./mat4.js";import{a}from"./mat4f64.js";import{o}from"./vec2.js";import{c as n,f as l}from"./vec2f64.js";import{s as c,t as p,p as f,b as u,q as d,c as h,l as m,h as g,r as S,i as v,d as O}from"./vec3.js";import{c as y,f as b}from"./vec3f64.js";import{b as A,a as T,f as P}from"./vec4f64.js";import{c as E}from"./aaBoundingRect.js";import{b as I}from"./BufferView.js";import{d as _,e as C}from"./FloatsPassUniform.js";import{n as x}from"./InterleavedLayout.js";import{S as R}from"./ShaderOutput.js";import{H as j}from"./HUDVisibility.glsl.js";import{G as D,a as L}from"./GLTextureMaterial.js";import{D as U,a as w,b as z,c as V,p as M,v as N,R as F}from"./Material.js";import{R as B}from"./RenderSlot.js";import{a as G}from"./Util.js";import{V as H}from"./VertexAttribute.js";import{i as W,j as X,k as q,l as Y,m as Z,o as J}from"./DefaultBufferWriter.js";import{H as k,c as Q}from"./HUDMaterial.glsl.js";import{V as K}from"./ViewingMode.js";import{R as $,S as ee,P as te}from"./Program2.js";import{o as se}from"./OrderIndependentTransparency.js";import{T as ie}from"./TransparencyPassType.js";import{f as re,g as ae,e as oe}from"./enums3.js";import{b as ne,d as le,m as ce,a as pe}from"./renderState2.js";import{_ as fe}from"./tslib.es6.js";import{p as ue}from"./ShaderTechniqueConfiguration.js";import{D as de}from"./Texture2.js";class he{constructor(){this.factor=new me,this.factorAlignment=new me}}class me{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}class ge extends ee{initializeConfiguration(e,t){t.spherical=e.viewingMode===K.Global}initializeProgram(e){return new te(e.rctx,ge.shader.get().build(this.configuration),U)}initializePipeline(){const e=this.configuration.transparencyPassType,t=this.configuration,s=e===ie.NONE,i=e===ie.FrontFace,r=this.configuration.hasPolygonOffset?Se:null,a=(s||i)&&t.output!==R.Highlight&&(t.depthEnabled||t.occlusionPass)?le:null;return ce({blending:t.output===R.Color||t.output===R.Alpha||t.output===R.Highlight?s?ve:se(e):null,depthTest:{func:ae.LEQUAL},depthWrite:a,colorWrite:pe,polygonOffset:r})}get primitiveType(){return this.configuration.occlusionPass?oe.POINTS:oe.TRIANGLES}}ge.shader=new $(k,(()=>import("./HUDMaterial.glsl.js").then((e=>e.H))));const Se={factor:0,units:-4},ve=ne(re.ONE,re.ONE_MINUS_SRC_ALPHA);class Oe extends de{constructor(){super(...arguments),this.output=R.Color,this.transparencyPassType=ie.NONE,this.screenCenterOffsetUnitsEnabled=!1,this.spherical=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.debugDrawLabelBorder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.depthEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.multipassEnabled=!1,this.cullAboveGround=!1,this.occlusionPass=!1,this.objectAndLayerIdColorInstanced=!1}}fe([ue({count:R.COUNT})],Oe.prototype,"output",void 0),fe([ue({count:ie.COUNT})],Oe.prototype,"transparencyPassType",void 0),fe([ue()],Oe.prototype,"screenCenterOffsetUnitsEnabled",void 0),fe([ue()],Oe.prototype,"spherical",void 0),fe([ue()],Oe.prototype,"occlusionTestEnabled",void 0),fe([ue()],Oe.prototype,"signedDistanceFieldEnabled",void 0),fe([ue()],Oe.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),fe([ue()],Oe.prototype,"vvSize",void 0),fe([ue()],Oe.prototype,"vvColor",void 0),fe([ue()],Oe.prototype,"hasVerticalOffset",void 0),fe([ue()],Oe.prototype,"hasScreenSizePerspective",void 0),fe([ue()],Oe.prototype,"debugDrawLabelBorder",void 0),fe([ue()],Oe.prototype,"hasSlicePlane",void 0),fe([ue()],Oe.prototype,"hasPolygonOffset",void 0),fe([ue()],Oe.prototype,"depthEnabled",void 0),fe([ue()],Oe.prototype,"pixelSnappingEnabled",void 0),fe([ue()],Oe.prototype,"draped",void 0),fe([ue()],Oe.prototype,"multipassEnabled",void 0),fe([ue()],Oe.prototype,"cullAboveGround",void 0),fe([ue()],Oe.prototype,"occlusionPass",void 0),fe([ue()],Oe.prototype,"objectAndLayerIdColorInstanced",void 0),fe([ue({constValue:!0})],Oe.prototype,"hasSliceInVertexProgram",void 0),fe([ue({constValue:!1})],Oe.prototype,"hasVvInstancing",void 0);class ye extends w{constructor(e){super(e,new Be),this._configuration=new Oe}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===B.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===R.Color||e===R.Alpha),e===R.Color&&(this._configuration.debugDrawLabelBorder=!!_.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,i,a,o,n){if(!(i.options.selectionMode&&i.options.hud&&e.visible&&i.point))return;const l=this.parameters,S=i.point,v=i.camera;let{scaleX:O,scaleY:b}=this._getScreenScale(e);O*=v.pixelRatio,b*=v.pixelRatio,s(Re,t),e.attributes.has(H.FEATUREATTRIBUTE)&&function(e){const t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],n=e[6],l=e[7],c=e[8],p=1/Math.sqrt(t*t+s*s+i*i),f=1/Math.sqrt(r*r+a*a+o*o),u=1/Math.sqrt(n*n+l*l+c*c);e[0]=t*p,e[1]=s*p,e[2]=i*p,e[3]=r*f,e[4]=a*f,e[5]=o*f,e[6]=n*u,e[7]=l*u,e[8]=c*u}(Re);const A=e.attributes.get(H.POSITION),T=e.attributes.get(H.SIZE),P=e.attributes.get(H.NORMAL),E=e.attributes.get(H.AUXPOS1);G(A.size>=3);const I=Q(l),_="screen"===this.parameters.centerOffsetUnits;for(let e=0;e<A.data.length/A.size;e++){const s=e*A.size;c(Ee,A.data[s],A.data[s+1],A.data[s+2]),p(Ee,Ee,t);const a=e*T.size;Ne[0]=T.data[a]*O,Ne[1]=T.data[a+1]*b,p(Ee,Ee,v.viewMatrix);const o=e*E.size;if(c(Le,E.data[o],E.data[o+1],E.data[o+2]),!_&&(Ee[0]+=Le[0],Ee[1]+=Le[1],0!==Le[2])){const e=Le[2];f(Le,Ee),u(Ee,Ee,d(Le,Le,e))}const C=e*P.size;if(c(Ie,P.data[C],P.data[C+1],P.data[C+2]),this._normalAndViewAngle(Ie,Re,v,ze),this._applyVerticalOffsetTransformationView(Ee,ze,v,Te),v.applyProjection(Ee,_e),_e[0]>-1){_&&(Le[0]||Le[1])&&(_e[0]+=Le[0]*v.pixelRatio,0!==Le[1]&&(_e[1]+=z(Le[1],Te.factorAlignment)*v.pixelRatio),v.unapplyProjection(_e,Ee)),_e[0]+=this.parameters.screenOffset[0]*v.pixelRatio,_e[1]+=this.parameters.screenOffset[1]*v.pixelRatio,_e[0]=Math.floor(_e[0]),_e[1]=Math.floor(_e[1]),V(Ne,Te.factor,Ne);const e=Ve*v.pixelRatio;let t=0;if(l.textureIsSignedDistanceField&&(t=l.outlineSize*v.pixelRatio/2),Ae(S,_e[0],_e[1],Ne,e,t,l,I)){const e=i.ray;if(p(xe,Ee,r(De,v.viewMatrix)),_e[0]=S[0],_e[1]=S[1],v.unprojectFromRenderScreen(_e,Ee)){const t=y();h(t,e.direction);const s=1/m(t);d(t,t,s),n(g(e.origin,Ee)*s,t,-1,!0,1,xe)}}}}}intersectDraped(e,t,s,i,r,a){const o=e.attributes.get(H.POSITION),n=e.attributes.get(H.SIZE),l=this.parameters,c=Q(l);let{scaleX:p,scaleY:f}=this._getScreenScale(e);p*=e.screenToWorldRatio,f*=e.screenToWorldRatio;const u=Me*e.screenToWorldRatio;for(let t=0;t<o.data.length/o.size;t++){const s=t*o.size,d=o.data[s],h=o.data[s+1],m=t*n.size;Ne[0]=n.data[m]*p,Ne[1]=n.data[m+1]*f;let g=0;l.textureIsSignedDistanceField&&(g=l.outlineSize*e.screenToWorldRatio/2),Ae(i,d,h,Ne,u,g,l,c)&&r(a.dist,a.normal,-1,!1)}}createBufferWriter(){return new We(this)}_normalAndViewAngle(e,t,i,r){return(function(e){return e instanceof Float32Array&&e.length>=16}(a=t)||function(e){return Array.isArray(e)&&e.length>=16}(a))&&(t=s(je,t)),S(r.normal,e,t),p(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=v(Ce,Fe),r;var a}_updateScaleInfo(e,t,s){const i=this.parameters;null!=i.screenSizePerspective?M(s,t,i.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),null!=i.screenSizePerspectiveAlignment?M(s,t,i.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,s,i,r,a,o){const n=this._normalAndViewAngle(t,s,r,ze);return this._applyVerticalGroundOffsetView(e,n,r,o),this._applyVerticalOffsetTransformationView(o,n,r,a),this._applyPolygonOffsetView(o,n,i[3],r,o),this._applyCenterOffsetView(o,i,o),o}applyShaderOffsetsNDC(e,t,s,i,r){return this._applyCenterOffsetNDC(e,t,s,i),null!=r&&h(r,i),this._applyPolygonOffsetNDC(i,t,s,i),i}_applyPolygonOffsetView(e,s,i,r,a){const o=r.aboveGround?1:-1;let n=Math.sign(i);0===n&&(n=o);const l=o*n;if(this.parameters.shaderPolygonOffset<=0)return h(a,e);const c=t(Math.abs(s.cosAngle),.01,1),p=1-Math.sqrt(1-c*c)/c/r.viewport[2];return d(a,e,l>0?p:1/p),a}_applyVerticalGroundOffsetView(e,t,s,i){const r=m(e),a=s.aboveGround?1:-1,o=s.computeRenderPixelSizeAtDist(r)*j,n=d(Ee,t.normal,a*o);return O(i,e,n),i}_applyVerticalOffsetTransformationView(e,t,s,i){const r=this.parameters;if(!r.verticalOffset?.screenLength){if(r.screenSizePerspective||r.screenSizePerspectiveAlignment){const s=m(e);this._updateScaleInfo(i,s,t.cosAngle)}else i.factor.scale=1,i.factorAlignment.scale=1;return e}const a=m(e),o=r.screenSizePerspectiveAlignment??r.screenSizePerspective,n=N(s,a,r.verticalOffset,t.cosAngle,o);return this._updateScaleInfo(i,a,t.cosAngle),d(t.normal,t.normal,n),O(e,e,t.normal)}_applyCenterOffsetView(e,t,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&h(s,e),i&&(s[0]+=t[0],s[1]+=t[1],t[2]&&(f(Ie,s),O(s,s,d(Ie,Ie,t[2])))),s}_applyCenterOffsetNDC(e,t,s,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==e&&h(i,e),r||(i[0]+=t[0]/s.fullWidth*2,i[1]+=t[1]/s.fullHeight*2),i}_applyPolygonOffsetNDC(e,t,s,i){const r=this.parameters.shaderPolygonOffset;if(e!==i&&h(i,e),r){const e=s.aboveGround?1:-1,a=e*Math.sign(t[3]);i[2]-=(a||e)*r}return i}produces(e,t){if(t===R.Color||t===R.Alpha||t===R.Highlight||t===R.ObjectAndLayerIdColor){if(e===B.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:s}=this.parameters;return e===(t?B.LABEL_MATERIAL:B.HUD_MATERIAL)||s&&e===B.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new be(e)}calculateRelativeScreenBounds(e,t,s=E()){return function(e,t,s,i=Pe){o(i,e.anchorPosition),i[0]*=-t[0],i[1]*=-t[1],i[0]+=e.screenOffset[0]*s,i[1]+=e.screenOffset[1]*s}(this.parameters,e,t,s),s[2]=s[0]+e[0],s[3]=s[1]+e[1],s}_getScreenScale(e){const t=e.attributes.get(H.FEATUREATTRIBUTE);if(null==t)return{scaleX:1,scaleY:1};const s=A(t.data,we),[i,r]=C(Ue,this.parameters,s);return{scaleX:i,scaleY:r}}}class be extends D{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(ge,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function Ae(e,t,s,i,r,a,o,n){let l=t-r-(n[0]>0?i[0]*n[0]:0),c=l+i[0]+2*r,p=s-r-(n[1]>0?i[1]*n[1]:0),f=p+i[1]+2*r;const u=o.distanceFieldBoundingBox;return o.textureIsSignedDistanceField&&null!=u&&(l+=i[0]*u[0],p+=i[1]*u[1],c-=i[0]*(1-u[2]),f-=i[1]*(1-u[3]),l-=a,c+=a,p-=a,f+=a),e[0]>l&&e[0]<c&&e[1]>p&&e[1]<f}const Te=new he,Pe=n(),Ee=y(),Ie=y(),_e=T(),Ce=y(),xe=y(),Re=i(),je=i(),De=a(),Le=y(),Ue=T(),we=T(),ze={normal:Ce,cosAngle:0},Ve=1,Me=2,Ne=[0,0],Fe=b(0,0,1);class Be extends L{constructor(){super(...arguments),this.renderOccluded=F.Occlude,this.isDecoration=!1,this.color=P(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=l(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=P(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const Ge=x().vec3f(H.POSITION).vec3f(H.NORMAL).vec2f(H.UV0).vec4u8(H.COLOR).vec2f(H.SIZE).vec4f(H.AUXPOS1).vec4f(H.FEATUREATTRIBUTE),He=Ge.clone().vec4u8(H.OBJECTANDLAYERIDCOLOR);class We{constructor(t){this._material=t,this.vertexBufferLayout=e("enable-feature:objectAndLayerId-rendering")?He:Ge}elementCount(e){return 6*e.attributes.get(H.POSITION).indices.length}write(e,t,s,i,r){W(s.attributes.get(H.POSITION),e,i.position,r,6),X(s.attributes.get(H.NORMAL),t,i.normal,r,6);const a=s.attributes.get(H.UV0).data;let o,n,l,c;if(null==a||a.length<4){const e=this._material.parameters;o=0,n=0,l=e.texCoordScale[0],c=e.texCoordScale[1]}else o=a[0],n=a[1],l=a[2],c=a[3];l=Math.min(1.99999,l+1),c=Math.min(1.99999,c+1);let p=s.attributes.get(H.POSITION).indices.length,f=r;const u=i.uv0;for(let e=0;e<p;++e)u.set(f,0,o),u.set(f,1,n),f++,u.set(f,0,l),u.set(f,1,n),f++,u.set(f,0,l),u.set(f,1,c),f++,u.set(f,0,l),u.set(f,1,c),f++,u.set(f,0,o),u.set(f,1,c),f++,u.set(f,0,o),u.set(f,1,n),f++;q(s.attributes.get(H.COLOR),4,i.color,r,6);const{data:d,indices:h}=s.attributes.get(H.SIZE);p=h.length;const m=i.size;f=r;for(let e=0;e<p;++e){const t=d[2*h[e]],s=d[2*h[e]+1];for(let e=0;e<6;++e)m.set(f,0,t),m.set(f,1,s),f++}if(s.attributes.get(H.AUXPOS1)?Y(s.attributes.get(H.AUXPOS1),i.auxpos1,r,6):Z(i.auxpos1,r,6*p),s.attributes.get(H.FEATUREATTRIBUTE)?Y(s.attributes.get(H.FEATUREATTRIBUTE),i.featureAttribute,r,6):Z(i.featureAttribute,r,6*p),null!=s.objectAndLayerIdColor){const e=s.attributes.get(H.POSITION)?.indices;if(e){const t=e.length,a=i.getField(H.OBJECTANDLAYERIDCOLOR,I);J(s.objectAndLayerIdColor,a,t,r,6)}}}}export{ye as H,he as S};
