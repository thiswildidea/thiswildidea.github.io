/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import s from"../request.js";import"./typedArrayUtil.js";import{L as e}from"./Logger.js";import{throwIfAborted as t,after as r,throwIfAbortError as o}from"../core/promiseUtils.js";import{M as a}from"./time.js";import{join as n,a as i,parseData as c}from"../core/urlUtils.js";import{a as p}from"./uuid.js";import{a as l,d as u,c as m,S as f,f as d}from"./External.js";import{U as y,N as g,B as w,a as h,b as j,C as P,c as b,d as T,e as A}from"./uploadAssetErrors.js";import{m as U,e as S,u as F,a as E,s as N}from"./progressUtils.js";import{i as x}from"./arcgisLayerUrl.js";import{e as D,b as v,c as O}from"./infoFor3D.js";import"../config.js";import"../core/lang.js";import"../kernel.js";import"../core/Error.js";import"../core/JSONSupport.js";import"./tslib.es6.js";import"../core/Accessor.js";import"../core/Handles.js";import"./maybe.js";import"../core/accessorSupport/decorators/subclass.js";import"./metadata.js";import"./utils.js";import"./handleUtils.js";import"./tracking.js";import"./ensureType.js";import"../core/accessorSupport/decorators/property.js";import"./ObjectPool.js";import"./ObservableBase.js";import"../core/scheduling.js";import"./nextTick.js";import"./PooledArray.js";import"./persistableUrlUtils.js";const I=1e6,k=20*I,B=2e9,q=3;async function C(s,e,r){const o=s.length;if(!o)return r?.onProgress?.(1),[];const a=U(o,r?.onProgress,"uploadAssets");return Promise.all(s.map(((s,o)=>async function(s,{layer:e,ongoingUploads:r},o){const a=r.get(s);if(a)return a;if(!function(s){return!!s.infoFor3D&&!!s.url}(e))throw new y;if(function(s,e){const{parsedUrl:t}=e;return null!=t&&s.metadata.externalSources.some((s=>l(s,t)))}(s,e))return o?.onProgress?.(1),s;const i=async function(s,e,r){const{metadata:o}=s,{displaySource:a}=o,i=L(a?.source,e),c=!!i,l=o.externalSources.length>0,u=c?async function(s,e,t){return{source:await z(s,e,t),original:!0}}(i,e,r):l?async function(s,e,t){const r=J(e),{externalSources:o}=s.metadata,a=function(s,e){for(const t of s){const s=L(t.source,e);if(s)return s}return null}(o,e);if(!a)throw new g;const i=U(F.uploadConvertibleSource,t?.onProgress,"uploadConvertibleSource"),c=await z(a,e,{onProgress:i.makeOnProgress("uploadEditSource")});s.addExternalSources([{source:c,original:!0}]);const p=a.reduce(((s,{asset:e})=>e instanceof File?s+e.size:s),0),l=i.simulate("serviceAssetsToGlb",E(p));try{const s=await async function(s,e,t){const r=s.map((({assetName:s,parts:e})=>({assetName:s,assetHash:e[0].partHash}))),o=e.capabilities?.operations.supportsAsyncConvert3D,a={f:"json",assets:JSON.stringify(r),transportType:"esriTransportTypeUrl",targetFormat:t,async:o},i=n(e.parsedUrl.path,"convert3D");let c;try{c=(await(o?$:H)(i,{query:a,responseType:"json",timeout:0})).data}catch(s){throw new P}const{supportedFormats:p}=e.infoFor3D;return c.assets.map((s=>{const e=v(s.contentType,p);if(!e)throw new j(e);return new m(s.assetName,s.contentType,[new f(s.assetURL,s.assetHash)])}))}(c,e,r);return{source:s}}finally{l.remove()}}(s,e,r):async function(s,e,r){const o=U(F.uploadLocalMesh,r?.onProgress,"uploadLocalMesh"),a=async function(s,e,r){const o=J(e),a=await s.load(r),n=await a.toBinaryGLTF({ignoreLocalTransform:!0});t(r);const i=await n.buffer();return t(r),{blob:new Blob([i.data],{type:i.type}),assetName:`${p()}.glb`,assetType:o}}(s,e,{...r,onProgress:o.makeOnProgress("meshToAssetBlob")});return{source:await M([a],e,{...r,onProgress:o.makeOnProgress("uploadAssetBlobs")}),extent:s.extent.clone(),original:!0}}(s,e,r),d=await u;return t(r),s.addExternalSources([d]),s}(s,e,o);r.set(s,i);try{await i}finally{r.delete(s)}return s}(s,e,{...r,onProgress:a.makeOnProgress(o)}))))}function L(s,e){if(!s)return null;const{infoFor3D:{supportedFormats:t,editFormats:r}}=e,o=d(s),a=new Array;let n=!1;for(let s=0;s<o.length;++s){const e=R(o[s],t);if(!e)return null;r.includes(e.assetType)&&(n=!0),a.push(e)}return n?a:null}function R(s,e){const t=u(s,e);return t?{asset:s,assetType:t}:null}async function z(s,e,r){const o=s.map((s=>async function(s,e){const{asset:r,assetType:o}=s;if(r instanceof File)return{blob:r,assetName:r.name,assetType:o};const a=await r.toBlob(e);return t(e),{blob:a,assetName:r.assetName,assetType:o}}(s,r)));return M(o,e,r)}async function M(r,a,i){const p=U(F.uploadAssetBlobs,i?.onProgress,"uploadAssetBlobs"),l=await function(r,a,i){const p=U(r.length,i?.onProgress,"prepareAssetItems");return Promise.all(r.map((async(r,l)=>{const u=async function(r,a,i){const{blob:p,assetType:l,assetName:u}=r;let m=null;try{const e=await async function({data:e,name:r,description:o},a,i){let c=null;try{const l=n(a,"uploads"),u=n(l,"info"),{data:m}=await s(u,{query:{f:"json"},responseType:"json"});t(i);const f=x(a),d=m.maxUploadFileSize*I,y=f?B:d,g=f?Math.min(k,d):k;if(e.size>y)throw new Error("Data too large");const w=n(l,"register"),{data:h}=await s(w,{query:{f:"json",itemName:(p=r,p.replaceAll("/","_").replaceAll("\\","_")),description:o},responseType:"json",method:"post"});if(t(i),!h.success)throw new Error("Registration failed");const{itemID:j}=h.item;c=n(l,j);const P=n(c,"uploadPart"),b=Math.ceil(e.size/g),T=new Array;for(let s=0;s<b;++s)T.push(e.slice(s*g,Math.min((s+1)*g,e.size)));const A=T.slice().reverse(),F=new Array,E=U(b,i?.onProgress,"uploadItem"),N=async()=>{for(;0!==A.length;){const e=T.length-A.length,r=A.pop(),o=new FormData,a=E.simulate(e,S(r.size));try{const a=r;o.append("f","json"),o.append("file",a),o.append("partId",`${e}`);const{data:n}=await s(P,{timeout:0,body:o,responseType:"json",method:"post"});if(t(i),!n.success)throw new Error("Part upload failed")}finally{a.remove()}}};for(let s=0;s<q&&0!==A.length;++s)F.push(N());await Promise.all(F);const D=n(c,"commit"),{data:v}=await s(D,{query:{f:"json",parts:T.map(((s,e)=>e)).join(",")},responseType:"json",method:"post"});if(t(i),!v.success)throw new Error("Commit failed");return v.item}catch(e){if(null!=c){const e=n(c,"delete");await s(e,{query:{f:"json"},responseType:"json",method:"post"})}throw e}var p}({data:p,name:u},a.url,i);t(i),m={assetType:l,assetUploadId:e.itemID}}catch(s){o(s),e.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${a.url} does not support the REST Uploads API.`)}if(!m){const s=await c(p);if(t(i),!s.isBase64)throw new T;m={assetType:l,assetData:s.data}}if(!m)throw new A;return{item:m,assetName:u}}(await r,a,{...i,onProgress:p.makeOnProgress(l)});return t(i),u})))}(r,a,{...i,onProgress:p.makeOnProgress("prepareAssetItems")});t(i);const u=l.map((({item:s})=>s)),{uploadResults:d}=await async function(e,r,o){const a=N(o?.onProgress);try{const a=await s(n(r.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(t(o),a.data.uploadResults.length!==e.length)throw new w(e.length,a.data.uploadResults.length);return a.data}finally{a.remove()}}(u,a,{...i,onProgress:p.makeOnProgress("uploadAssetItems")});return t(i),r.map(((s,e)=>function(s,e,t){const{success:r}=e;if(!r){const{error:t}=e;throw new h(s.assetName,t)}const{assetHash:o}=e,{assetName:a,item:{assetType:n}}=s,{infoFor3D:{supportedFormats:i}}=t,c=D(n,i);if(!c)throw new j(n);return new m(a,c,[new f(`${t.parsedUrl.path}/assets/${o}`,o)])}(l[e],d[e],a)))}function H(e,t){return s(e,t)}async function $(e,t){const o=(await s(e,t)).data.statusUrl;for(;;){const e=(await s(o,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return s(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new Error(e.status);case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new Error}await r(G)}}function J(s){const{infoFor3D:e}=s,t=v("model/gltf-binary",e.supportedFormats)??O("glb",e.supportedFormats);if(!t)throw new b;return t}const G=a(1e3);export{C as uploadAssets};
