/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.28/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import"../../geometry.js";import{rasterRendererTypes as e,websceneRasterRendererTypes as s,read as i}from"../../rasterRenderers.js";import r from"../../request.js";import o from"../../core/Error.js";import{L as n}from"../../chunks/Logger.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import{l}from"../../chunks/ensureType.js";import"../../chunks/typedArrayUtil.js";import{r as m}from"../../chunks/reader.js";import{subclass as c}from"../../core/accessorSupport/decorators/subclass.js";import{g as p,h as u}from"../../chunks/unitUtils.js";import{s as h}from"../../chunks/arcgisLayerUrl.js";import{u as d}from"../../chunks/commonProperties2.js";import f from"../support/DimensionalDefinition.js";import y from"../support/MultidimensionalSubset.js";import x from"../support/RasterFunction.js";import{R as g}from"../../chunks/RasterJobHandler.js";import b from"../support/TileInfo.js";import{JSONSupport as j}from"../../core/JSONSupport.js";import{EsriPromiseMixin as k}from"../../core/Promise.js";import{onAbort as I}from"../../core/promiseUtils.js";import R from"../support/LOD.js";import{R as S}from"../support/RasterInfo.js";import{b as w,c as v,d as T,e as M,a as F,h as _,f as P,g as D}from"../../chunks/multidimensionalUtils.js";import{g as C,a as J,p as H,d as B,b as U}from"../../chunks/RawBlockCache.js";import{c as O}from"../../chunks/pixelRangeUtils.js";import{d as z,R as E}from"../../chunks/RasterSymbolizer.js";import{m as L,h as A,j as N,k as W,u as V,d as q}from"../../chunks/vectorFieldUtils.js";import{l as G,g as $,p as Q,s as K,a as X,b as Z,c as Y,d as tt,e as et,f as st,h as it}from"../../chunks/rasterProjectionHelper.js";import rt from"../../geometry/Extent.js";import ot from"../../geometry/Point.js";import nt from"../../rest/support/FeatureSet.js";import at from"../support/PixelBlock.js";import{c as lt}from"../../chunks/rasterFunctionHelper.js";import{m as mt}from"../../chunks/stretchUtils.js";import{n as ct,b as pt,d as ut,a as ht,c as dt}from"../../chunks/rasterRendererHelper.js";import ft from"../../rest/support/ImageHistogramParameters.js";import{c as yt}from"../../chunks/dataUtils.js";import xt from"../../geometry/SpatialReference.js";import"../../geometry/Geometry.js";import"../../core/Accessor.js";import"../../core/Handles.js";import"../../chunks/maybe.js";import"../../chunks/metadata.js";import"../../core/lang.js";import"../../chunks/utils.js";import"../../chunks/handleUtils.js";import"../../chunks/ObjectPool.js";import"../../chunks/ObservableBase.js";import"../../chunks/tracking.js";import"../../core/scheduling.js";import"../../chunks/nextTick.js";import"../../chunks/PooledArray.js";import"../../chunks/time.js";import"../../config.js";import"../../chunks/jsonMap.js";import"../../chunks/Ellipsoid.js";import"../../chunks/assets.js";import"../../core/urlUtils.js";import"../../kernel.js";import"../../chunks/writer.js";import"../../geometry/Multipoint.js";import"../../chunks/zmUtils.js";import"../../geometry/support/webMercatorUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../geometry/Polygon.js";import"../../chunks/Axis.js";import"../../chunks/extentUtils.js";import"../../chunks/aaBoundingRect.js";import"../../chunks/mathUtils.js";import"../../chunks/vec3.js";import"../../chunks/vec3f64.js";import"../../chunks/common.js";import"../../geometry/Polyline.js";import"../../chunks/typeUtils.js";import"../../geometry/support/jsonUtils.js";import"../../renderers/ClassBreaksRenderer.js";import"../../symbols.js";import"../../symbols/CIMSymbol.js";import"../../chunks/enumeration.js";import"../support/fieldUtils.js";import"../../core/sql.js";import"../../intl.js";import"../../chunks/date.js";import"../../chunks/locale.js";import"../../chunks/timeZoneUtils.js";import"../../chunks/datetime.js";import"../../chunks/messages.js";import"../../chunks/arcadeOnDemand.js";import"../../symbols/Symbol.js";import"../../Color.js";import"../../chunks/colorUtils.js";import"../../symbols/ExtrudeSymbol3DLayer.js";import"../../symbols/Symbol3DLayer.js";import"../../chunks/utils4.js";import"../../symbols/edges/Edges3D.js";import"../../chunks/screenUtils.js";import"../../chunks/materialUtils.js";import"../../chunks/opacityUtils.js";import"../../symbols/edges/SketchEdges3D.js";import"../../symbols/edges/SolidEdges3D.js";import"../../chunks/Symbol3DMaterial.js";import"../../symbols/FillSymbol.js";import"../../symbols/SimpleLineSymbol.js";import"../../symbols/LineSymbol.js";import"../../symbols/LineSymbolMarker.js";import"../../chunks/lineMarkers.js";import"../../symbols/FillSymbol3DLayer.js";import"../../symbols/patterns/LineStylePattern3D.js";import"../../symbols/patterns/StylePattern3D.js";import"../../chunks/utils5.js";import"../../chunks/colors.js";import"../../chunks/symbolLayerUtils3D.js";import"../../chunks/aaBoundingBox.js";import"../../symbols/Font.js";import"../../symbols/IconSymbol3DLayer.js";import"../../chunks/persistableUrlUtils.js";import"../../chunks/Symbol3DAnchorPosition2D.js";import"../../symbols/LabelSymbol3D.js";import"../../core/Collection.js";import"../../core/Evented.js";import"../../chunks/shared.js";import"../../chunks/SimpleObservable.js";import"../../symbols/Symbol3D.js";import"../../chunks/collectionUtils.js";import"../../portal/Portal.js";import"../../core/Loadable.js";import"../../portal/PortalGroup.js";import"../../portal/PortalQueryParams.js";import"../../portal/PortalQueryResult.js";import"../../portal/PortalUser.js";import"../../portal/PortalFolder.js";import"../../symbols/LineSymbol3DLayer.js";import"../../symbols/LineStyleMarker3D.js";import"../../core/Clonable.js";import"../../symbols/ObjectSymbol3DLayer.js";import"../../symbols/PathSymbol3DLayer.js";import"../../symbols/TextSymbol3DLayer.js";import"../../symbols/WaterSymbol3DLayer.js";import"../../symbols/support/StyleOrigin.js";import"../../chunks/Thumbnail.js";import"../../chunks/calloutUtils.js";import"../../symbols/callouts/Callout3D.js";import"../../symbols/callouts/LineCallout3D.js";import"../../symbols/support/Symbol3DVerticalOffset.js";import"../../symbols/LineSymbol3D.js";import"../../symbols/MarkerSymbol.js";import"../../symbols/MeshSymbol3D.js";import"../../symbols/PictureFillSymbol.js";import"../../chunks/urlUtils.js";import"../../symbols/PictureMarkerSymbol.js";import"../../symbols/PointSymbol3D.js";import"../../symbols/PolygonSymbol3D.js";import"../../core/reactiveUtils.js";import"../../chunks/asyncUtils.js";import"../../symbols/SimpleFillSymbol.js";import"../../symbols/SimpleMarkerSymbol.js";import"../../symbols/TextSymbol.js";import"../../symbols/WebStyleSymbol.js";import"../../renderers/Renderer.js";import"../../renderers/support/AuthoringInfo.js";import"../../renderers/support/AuthoringInfoVisualVariable.js";import"../../chunks/colorRamps.js";import"../../rest/support/AlgorithmicColorRamp.js";import"../../rest/support/ColorRamp.js";import"../../rest/support/MultipartColorRamp.js";import"../../renderers/mixins/VisualVariablesMixin.js";import"../../renderers/visualVariables/ColorVariable.js";import"../../renderers/visualVariables/VisualVariable.js";import"../../chunks/LegendOptions.js";import"../../renderers/visualVariables/support/ColorStop.js";import"../../renderers/visualVariables/OpacityVariable.js";import"../../renderers/visualVariables/support/OpacityStop.js";import"../../renderers/visualVariables/RotationVariable.js";import"../../renderers/visualVariables/SizeVariable.js";import"../../renderers/visualVariables/support/SizeStop.js";import"../../chunks/visualVariableUtils.js";import"../../Graphic.js";import"../../PopupTemplate.js";import"../../popup/content.js";import"../../popup/content/AttachmentsContent.js";import"../../popup/content/Content.js";import"../../popup/content/CustomContent.js";import"../../popup/content/ExpressionContent.js";import"../../popup/ElementExpressionInfo.js";import"../../popup/content/FieldsContent.js";import"../../popup/FieldInfo.js";import"../../popup/support/FieldInfoFormat.js";import"../../popup/content/MediaContent.js";import"../../popup/content/BarChartMediaInfo.js";import"../../popup/content/mixins/ChartMediaInfo.js";import"../../popup/content/mixins/MediaInfo.js";import"../../popup/content/support/ChartMediaInfoValue.js";import"../../popup/content/support/ChartMediaInfoValueSeries.js";import"../../chunks/chartMediaInfoUtils.js";import"../../popup/content/ColumnChartMediaInfo.js";import"../../popup/content/ImageMediaInfo.js";import"../../popup/content/support/ImageMediaInfoValue.js";import"../../popup/content/LineChartMediaInfo.js";import"../../popup/content/PieChartMediaInfo.js";import"../../popup/content/RelationshipContent.js";import"../../popup/support/RelatedRecordsInfoFieldOrder.js";import"../../popup/content/TextContent.js";import"../../popup/ExpressionInfo.js";import"../../popup/LayerOptions.js";import"../../popup/RelatedRecordsInfo.js";import"../../support/actions/ActionBase.js";import"../../core/Identifiable.js";import"../../support/actions/ActionButton.js";import"../../support/actions/ActionToggle.js";import"../../chunks/compilerUtils.js";import"../../chunks/lengthUtils.js";import"../../renderers/support/ClassBreakInfo.js";import"../../chunks/commonProperties.js";import"../../symbols/support/jsonUtils.js";import"../../chunks/layerUtils2.js";import"../../renderers/FlowRenderer.js";import"../../renderers/RasterColormapRenderer.js";import"../../renderers/support/ColormapInfo.js";import"../../chunks/colorRampUtils.js";import"../../chunks/colorUtils2.js";import"../../chunks/vec4.js";import"../../chunks/vec4f64.js";import"../../renderers/RasterShadedReliefRenderer.js";import"../../renderers/RasterStretchRenderer.js";import"../../chunks/stretchRendererUtils.js";import"../../renderers/UniqueValueRenderer.js";import"../../chunks/diffUtils.js";import"../../renderers/support/UniqueValue.js";import"../../renderers/support/UniqueValueClass.js";import"../../renderers/support/UniqueValueGroup.js";import"../../renderers/support/UniqueValueInfo.js";import"../../chunks/styleUtils.js";import"../../renderers/VectorFieldRenderer.js";import"../../geometry/support/normalizeUtils.js";import"../../chunks/normalizeUtilsCommon.js";import"../../chunks/simplify.js";import"../../chunks/utils6.js";import"../../chunks/utils7.js";import"../../chunks/utils8.js";import"../../chunks/jsonUtils.js";import"../../chunks/parser.js";import"../../chunks/utils3.js";import"../../chunks/mat4.js";import"../../chunks/_commonjsHelpers.js";import"../../symbols/support/cimSymbolUtils.js";import"../../chunks/utils9.js";import"../../chunks/LRUCache.js";import"../../chunks/MemCache.js";import"../../TimeExtent.js";import"../../chunks/timeUtils.js";import"../../chunks/layerContainerType.js";import"../../support/timeUtils.js";import"../../chunks/ElevationInfo.js";import"../../chunks/unitConversionUtils.js";import"../../core/workers/workers.js";import"../../core/workers/Connection.js";import"../../chunks/Queue.js";import"../../core/workers/RemoteClient.js";import"../../chunks/TileKey.js";import"../support/RasterBandInfo.js";import"../support/RasterSensorInfo.js";import"../../geometry/projection.js";import"../../chunks/projectBuffer.js";import"../../chunks/geodesicConstants.js";import"../../geometry/support/GeographicTransformation.js";import"../../geometry/support/GeographicTransformationStep.js";import"../../chunks/zscale.js";import"../support/Field.js";import"../../chunks/domains.js";import"../support/CodedValueDomain.js";import"../support/Domain.js";import"../support/InheritedDomain.js";import"../support/RangeDomain.js";import"../../chunks/fieldType.js";import"../support/rasterFunctionConstants.js";import"../../chunks/focalStatUtils.js";import"../../chunks/generateRendererUtils.js";import"../support/MosaicRule.js";let gt=class extends(k(j)){constructor(){super(...arguments),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=G();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t?.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:b.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=$(t.spatialReference);return null!=e&&t.extent.width>=e/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return null==t||"gcs-shift"===t.type}set rasterJobHandler(t){this._set("rasterJobHandler",t),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((e=>e.rasterJobHandler=t))}set url(t){this._set("url",h(t,n.getLogger(this)))}async open(t){throw new o("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,s,i={}){const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,e,s,r);return this.fetchPixels(o,r.size[0],r.size[1],i)}async identify(t,e={}){t=l(ot,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:i}=e,{rasterInfo:r}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:n}=r;let{transposedVariableName:a}=e;const m=null!=n&&o&&(null!=i||w(s));m&&!a&&(a=null!=s&&s.length>0?s[0].variableName??void 0:n.variables[0].name,e={...e,transposedVariableName:a}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:c,extent:p}=r,{datumTransformation:u}=e;let h=Q(t,c,u);if(!p.intersects(h))return{location:h,value:null};if(null!=r.transform){const t=r.transform.inverseTransform(h);if(!r.nativeExtent.intersects(t))return{location:t,value:null};h=t}let d=0;const f=null!=a&&null!=n&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const t=this.primaryRasters.rasters[0];if(f)return t.identify(h,e);const{pixelSize:s}=r,i=3,o=s.x*i/2,n=s.y*i/2,a=new rt({xmin:h.x-o,xmax:h.x+o,ymin:h.y-n,ymax:h.y+n,spatialReference:c}),l={interpolation:"nearest"},{pixelBlock:m}=await t.fetchPixels(a,i,i,l),{pixelBlock:p}=await this.fetchPixels(a,i,i,l);if(null==m)return{location:h,value:null};const u=Math.floor(i*i*.5),d=!m.mask||m.mask[u]?m.pixels.map((t=>t[u])):null;let y;return null!=p&&(y=!p.mask||p.mask[u]?p.pixels.map((t=>t[u])):void 0),{location:h,value:d,processedValue:y,pyramidLevel:0}}if(!f)if(e.srcResolution)d=K(e.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,e),null==d)return{location:h,value:null};const y=this.identifyPixelLocation(h,d,null,f);if(null===y)return{location:h,value:null};const{row:x,col:g,rowOffset:b,colOffset:j,blockWidth:k}=y,I=a??e.sliceId,R=C(this.url,I),S=`${d}/${x}/${g}`;let v=J(R,null,S);null==v&&(v=this.fetchRawTile(d,x,g,e),H(R,null,S,v));const T=await v;if(!T?.pixels?.length)return{location:h,value:null};const M=b*k+j;return this._processIdentifyResult(T,{srcLocation:h,position:M,pyramidLevel:d,useTransposedTile:!!f,requestSomeSlices:m,identifyOptions:e})}async fetchPixels(t,e,s,i={}){t=X(t),i=this._getRequestOptionsWithSliceId(i);const{_hasNoneOrGCSShiftTransform:r}=this;if(i.requestRawData&&r)return this._fetchPixels(t,e,s,i);const o=$(t.spatialReference),n=Z(t);if(null==o||0===n||1===n&&this._isGlobalWrappableSource&&r)return this._fetchPixels(t,e,s,i);if(n>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:m}=t,c=Math.round(o/(m-l)*e),p=c-Math.round((o/2-l)/(m-l)*e);let u=0;const h=[];for(let r=0;r<=n;r++){const d=new rt({xmin:0===r?l:-o/2,xmax:r===n?m-o*r:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),f=0===r?c-p:r===n?e-u:c;u+=f,h.push(f);const y=i.disableWrapAround&&r>0?null:this._fetchPixels(d,f,s,i);a.push(y)}const d=(await Promise.all(a)).map((t=>t?.pixelBlock));let f=null;const y={width:e,height:s};return f=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:h},i)).pixelBlock:L(d,y,{blockWidths:h}),{extent:t,srcExtent:Y(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:f}}async fetchRawPixels(t,e,s,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const r=await this._fetchRawTiles(t,e,s,i),{nativeExtent:o,nativePixelSize:n,storageInfo:a}=this.rasterInfo,l=2**t,m=n.x*l,c=n.y*l,p=new rt({xmin:o.xmin+m*e.x,xmax:o.xmin+m*(e.x+s.width-1),ymin:o.ymax-c*(e.y+s.height-1),ymax:o.ymax-c*e.y,spatialReference:o.spatialReference});if(!r)return{extent:p,srcExtent:p,pixelBlock:null};const{pixelBlocks:u,mosaicSize:h}=r;if(1===u.length&&null!=u[0]&&u[0].width===s.width&&u[0].height===s.height)return{extent:p,srcExtent:p,pixelBlock:r.pixelBlocks[0]};const d=t>0?a.pyramidBlockWidth:a.blockWidth,f=t>0?a.pyramidBlockHeight:a.blockHeight,y={x:e.x%d,y:e.y%f};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:u,srcMosaicSize:h,destDimension:s,clipOffset:y,clipSize:s,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:L(u,h,{clipOffset:y,clipSize:s}),{extent:p,srcExtent:p,pixelBlock:x}}fetchRawTile(t,e,s,i){throw new o("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Y(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?z(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,s=0){const{customFetchParameters:i}=this.ioConfig,{range:o,query:n,headers:a}=e;s=s??e.retryCount??this.ioConfig.retryCount;const l=o?{Range:`bytes=${o.from}-${o.to}`}:null;try{return await r(t,{...e,query:{...n,...i},headers:{...a,...l}})}catch(i){if(s>0)return s--,this.request(t,e,s);throw i}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return null==e||null==t||0===t.length?null:v(t,e)}getTileExtentFromTileInfo(t,e,s,i){const r=i.lodAt(t);return this.getTileExtent({x:r.resolution,y:r.resolution},e,s,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:s,pixelSize:i}=this.rasterInfo;if(!t.tileInfo){const r=[],o=t.maximumPyramidLevel||0;let n=Math.max(i.x,i.y),a=1/.0254*96*n;for(let t=0;t<=o;t++)r.unshift(new R({level:o-t,resolution:n,scale:a})),n*=2,a*=2;const l=new ot({x:s.xmin,y:s.ymax,spatialReference:e});t.tileInfo=new b({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:r}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,s=512,i){const{width:r,height:o,nativeExtent:n,pixelSize:a,spatialReference:l}=t,m=new ot({x:n.xmin,y:n.ymax,spatialReference:l});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(r,o))/Math.LN2-8)));const c=this.computeBlockBoundary(n,512,512,{x:n.xmin,y:n.ymax},[a],i);t.storageInfo=new S({blockWidth:e,blockHeight:s,pyramidBlockWidth:e,pyramidBlockHeight:s,origin:m,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:c})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,s,i,r,o=0,n=2){if(1===r.length&&o>0){r=[...r];let{x:t,y:e}=r[0];for(let s=0;s<o;s++)t*=n,e*=n,r.push({x:t,y:e})}const a=[],{x:l,y:m}=i;for(let i=0;i<r.length;i++){const{x:o,y:n}=r[i];a.push({minCol:Math.floor((t.xmin-l+.1*o)/e/o),maxCol:Math.floor((t.xmax-l-.1*o)/e/o),minRow:Math.floor((m-t.ymax+.1*n)/s/n),maxRow:Math.floor((m-t.ymin-.1*n)/s/n)})}return a}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===t)return e;if(null!=s&&s.length)return s[t-1];const r=i**t;return{x:e.x*r,y:e.y*r}}identifyPixelLocation(t,e,s,i){const{spatialReference:r,nativeExtent:o,storageInfo:n}=this.rasterInfo,{maximumPyramidLevel:a,origin:l,transposeInfo:m}=n,c=i&&null!=m?m.tileSize[0]:n.blockWidth,p=i&&null!=m?m.tileSize[1]:n.blockHeight,u=Q(t,r,s);if(!o.intersects(u))return null;if(e<0||e>a)return null;const h=this.getPyramidPixelSize(e),{x:d,y:f}=h,y=(l.y-u.y)/f/p,x=(u.x-l.x)/d/c,g=Math.min(p-1,Math.floor((y-Math.floor(y))*p)),b=Math.min(c-1,Math.floor((x-Math.floor(x))*c));return{pyramidLevel:e,row:Math.floor(y),col:Math.floor(x),rowOffset:g,colOffset:b,blockWidth:c,srcLocation:u}}getTileExtent(t,e,s,i,r,o){const[n,a]=o,l=i.x+s*n*t.x,m=l+n*t.x,c=i.y-e*a*t.y,p=c-a*t.y;return new rt({xmin:l,xmax:m,ymin:p,ymax:c,spatialReference:r})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,s){const i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<s||i.minRow>e||i.minCol>s}async _fetchPixels(t,e,s,i={}){let r=Z(t);if(r>=2)return{extent:t,pixelBlock:null};const o=this._getSourceDataInfo(t,e,s,i),{pyramidLevel:n,srcResolution:a,srcExtent:l,srcWidth:m,srcHeight:c,ul:p}=o;if(0===m||0===c)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:u}=this,h=u.transform,d="gcs-shift"===h?.type,f=null!=$(t.spatialReference);!d&&f||(r=Z(o.srcExtent,d));const y=await this._fetchRawTiles(n,p,{width:m,height:c,wrapCount:r},i);if(!y)return{extent:t,srcExtent:l,pixelBlock:null};const x=u.storageInfo,g=n>0?x.pyramidBlockWidth:x.blockWidth,b=n>0?x.pyramidBlockHeight:x.blockHeight;let{x:j,y:k}=u.pixelSize;if(n>0){const{pyramidResolutions:t,pyramidScalingFactor:e}=x;if(null!=t&&t[n-1])({x:j,y:k}=t[n-1]);else{const t=e**n;j*=t,k*=t}}const I=u.spatialReference,R=new ot({x:j,y:k,spatialReference:I}),S=g===m&&b===c&&p.x%g==0&&p.y%b==0,w=new ot({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),v=!t.spatialReference.equals(I),T=I.isGeographic?1e-9:1e-4,{datumTransformation:M}=i;if(!v&&S&&1===y.pixelBlocks.length&&g===e&&b===s&&this._isSameResolution(a,w,T))return{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:y.pixelBlocks[0]};const F=f&&null!=$(l.spatialReference)&&this._hasNoneOrGCSShiftTransform,_=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");_&&!this.rasterJobHandler&&await G();const P=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w.toJSON(),datumTransformation:M,rasterTransform:h,hasWrapAround:r>0||F,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:_},i):tt({projectedExtent:t,srcBufferExtent:y.extent,pixelSize:w,datumTransformation:M,rasterTransform:h,hasWrapAround:r>0||F,isAdaptive:!1,includeGCSGrid:_});let D;const C=!i.requestRawData,J={rows:P.spacing[0],cols:P.spacing[1]},H=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(n,y.extent.xmin):void 0,{pixelBlocks:B,mosaicSize:U,isPartiallyFilled:O}=y;let z=null;if(this.rasterJobHandler){const t=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:U,destDimension:C?{width:e,height:s}:null,coefs:C?P.coefficients:null,sampleSpacing:C?J:null,projectDirections:_,gcsGrid:_?P.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:H,blockWidths:null},i);({pixelBlock:D,localNorthDirections:z}=t)}else{const t=L(B,U,{alignmentInfo:H});D=C?A(t,{width:e,height:s},P.coefficients,J,i.interpolation):t,_&&P.gcsGrid&&(z=N({width:e,height:s},P.gcsGrid),D=W(D,this.rasterInfo.dataType,z))}return i.requestRawData||_?{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:D,transformGrid:P,localNorthDirections:z,isPartiallyFilled:O}:{extent:t,srcExtent:l,srcTilePixelSize:R,pixelBlock:D}}async _fetchRawTiles(t,e,s,i){const{origin:r,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:n,blockHeight:a}=this.getBlockWidthHeight(t);let{x:l,y:m}=e,{width:c,height:p,wrapCount:u}=s;const h=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(l-=i.buffer.cols,m-=i.buffer.rows,c+=2*i.buffer.cols,p+=2*i.buffer.rows);let d=0,f=0,y=0;u&&null!=h&&(({worldColumnCountFromOrigin:f,originColumnOffset:y,rightPadding:d}=h),f*h.blockWidth-d>=l+c&&(d=0));const x=Math.floor(l/n),g=Math.floor(m/a),b=Math.floor((l+c+d-1)/n),j=Math.floor((m+p+d-1)/a),k=o[t];if(!k)return null;const{minRow:I,minCol:R,maxCol:S,maxRow:w}=k;if(0===u&&(j<I||b<R||g>w||x>S))return null;const v=new Array;let T=!1;const M=null==this.ioConfig.allowPartialFill?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let e=g;e<=j;e++)for(let s=x;s<=b;s++){let r=s;if(!i.disableWrapAround&&u&&null!=h&&f<=s&&(r=s-f-y),e>=I&&r>=R&&w>=e&&S>=r){const s=this._fetchRawTile(t,e,r,i);M?v.push(new Promise((t=>{s.then((e=>t(e))).catch((()=>{T=!0,t(null)}))}))):v.push(s)}else v.push(Promise.resolve(null))}if(0===v.length)return null;const F=await Promise.all(v),_={height:(j-g+1)*a,width:(b-x+1)*n},{spatialReference:P}=this.rasterInfo,D=this.getPyramidPixelSize(t),{x:C,y:J}=D;return{extent:new rt({xmin:r.x+x*n*C,xmax:r.x+(b+1)*n*C,ymin:r.y-(j+1)*a*J,ymax:r.y-g*a*J,spatialReference:P}),pixelBlocks:F,mosaicSize:_,isPartiallyFilled:T}}_isSameResolution(t,e,s){return Math.abs(t.x-e.x)<s&&Math.abs(t.y-e.y)<s}_fetchRawTile(t,e,s,i){const r=this.rasterInfo.storageInfo.blockBoundary[t];if(!r)return Promise.resolve(null);const{minRow:o,minCol:n,maxCol:a,maxRow:l}=r;if(e<o||s<n||e>l||s>a)return Promise.resolve(null);const m=C(this.url,i.sliceId),c=`${t}/${e}/${s}`;let p=J(m,i.registryId,c);if(null==p){const r=new AbortController;p=this.fetchRawTile(t,e,s,{...i,signal:r.signal}),H(m,i.registryId,c,p,r),p.catch((()=>B(m,i.registryId,c)))}return i.signal&&I(i,(()=>{U(m,i.registryId,c)})),p}_computeMagDirValues(t){const{bandCount:e,dataType:s}=this.rasterInfo;if((2!==e||"vector-magdir"!==s)&&"vector-uv"!==s||2!==t?.length||!t[0]?.length)return null;const i=t[0].length;if("vector-magdir"===s){const e=t[1].map((t=>(t+360)%360));return[t[0],e]}const[r,o]=t,n=[],a=[];for(let t=0;t<i;t++){const[e,s]=V([r[t],o[t]]);n.push(e),a.push(s)}return[n,a]}_getRasterTileAlignmentInfo(t,e){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=et(this.rasterInfo)),null==this._rasterTileAlighmentInfo.pyramidsInfo?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,s,i={}){const r={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(r.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,r));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:n,srcHeight:a,pyramidLevel:l}=r,m=n/e,c=a/s,p=l<o&&m*c>=16,u=l===o&&this._requireTooManySrcTiles(n,a,e,s);if(p||u||0===n||0===a){const n=new ot({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let a=st(n,this.rasterInfo.spatialReference,t,r.datumTransformation);const u=!a||i.srcResolution&&a.x+a.y<i.srcResolution.x+i.srcResolution.y;if(p&&i.srcResolution&&u){const t=Math.round(Math.log(Math.max(m,c))/Math.LN2)-1;if(o-l+3>=t){const e=2**t;a={x:i.srcResolution.x*e,y:i.srcResolution.y*e}}}a&&(r.srcResolution=a,this._updateSourceDataInfo(t,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,e,s)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(t,e,s,i){const{tileInfo:r}=this.rasterInfo.storageInfo;return Math.ceil(t/r.size[0])*Math.ceil(e/r.size[1])>=256||t/s>8||e/i>8}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const{rasterInfo:s}=this,i=s.spatialReference,{srcResolution:r,datumTransformation:o}=e,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=K(r,s,this.ioConfig.sampling);if(l)return;let m=e.srcExtent||Y(t,i,o);if(null==m)return;const c=s.transform;c&&(m=c.inverseTransform(m)),e.srcExtent=m;const{x:p,y:u}=s.storageInfo.origin,h=Math.floor((m.xmin-p)/a.x+.1),d=Math.floor((u-m.ymax)/a.y+.1),f=Math.floor((m.xmax-p)/a.x-.1),y=Math.floor((u-m.ymin)/a.y-.1),x=m.width<.1*a.x?0:f-h+1,g=m.height<.1*a.y?0:y-d+1;e.pyramidLevel=n,e.pyramidResolution=a,e.srcWidth=x,e.srcHeight=g,e.ul={x:h,y:d}}_getRequestOptionsWithSliceId(t){return null!=this.rasterInfo.multidimensionalInfo&&null==t.sliceId&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:s,position:i,pyramidLevel:r,useTransposedTile:o}=e,n=t.pixels[0].length/t.width/t.height;if(t.mask&&!t.mask[i])return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(null==a||!o){const e=t.pixels.map((t=>t[i])),o={location:s,value:e,pyramidLevel:r},n=this._computeMagDirValues(e.map((t=>[t])));return n?.length&&(o.magdirValue=n.map((t=>t[0]))),o}let l=t.pixels.map((t=>t.slice(i*n,i*n+n))),m=this._computeMagDirValues(l);const{requestSomeSlices:c,identifyOptions:p}=e;let u=T(a,p.transposedVariableName);if(c){const t=M(u,p.multidimensionalDefinition,p.timeExtent);l=l.map((e=>t.map((t=>e[t])))),m=m?.map((e=>t.map((t=>e[t])))),u=t.map((t=>u[t]))}const h=t.noDataValues||this.rasterInfo.noDataValue,d={pixels:l,pixelType:t.pixelType};let y;return null!=h&&(O(d,h),y=d.mask),{location:s,value:null,dataSeries:u.map(((t,e)=>{const s={value:0===y?.[e]?null:l.map((t=>t[e])),multidimensionalDefinition:t.multidimensionalDefinition.map((t=>new f({...t,isSlice:!0})))};return m?.length&&(s.magdirValue=[m[0][e],m[1][e]]),s})),pyramidLevel:r}}};t([a()],gt.prototype,"_rasterTileAlighmentInfo",void 0),t([a({readOnly:!0})],gt.prototype,"_isGlobalWrappableSource",null),t([a({readOnly:!0})],gt.prototype,"_hasNoneOrGCSShiftTransform",null),t([a()],gt.prototype,"rasterJobHandler",null),t([a(d)],gt.prototype,"url",null),t([a({type:String,json:{write:!0}})],gt.prototype,"datasetName",void 0),t([a({type:String,json:{write:!0}})],gt.prototype,"datasetFormat",void 0),t([a()],gt.prototype,"hasUniqueSourceStorageInfo",void 0),t([a()],gt.prototype,"rasterInfo",void 0),t([a()],gt.prototype,"ioConfig",void 0),t([a()],gt.prototype,"sourceJSON",void 0),gt=t([c("esri.layers.support.rasterDatasets.BaseRaster")],gt);const bt=gt;let jt=class extends bt{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null}async open(t){await this.init();const{rasterFunction:e}=this;this.primaryRasters?.rasters?.length?e.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((t=>t.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:i}=this.primaryRasters,r=s.map((e=>e.rasterInfo?void 0:e.open(t)));await Promise.all(r);const n=s.map((({rasterInfo:t})=>t)),a=e.bind({rasterInfos:n,rasterIds:i});if(!a.success||0===n.length)throw new o("raster-function:open",`cannot bind the function: ${a.error??""}`);const l="Table"===e.functionName?e:e.functionArguments?.raster;"Table"===l?.functionName&&(e.rasterInfo.attributeTable=nt.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const m=n[0];this.hasUniqueSourceStorageInfo=1===n.length||n.slice(1).every((t=>this._hasSameStorageInfo(t,m))),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",e.rasterInfo)}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async fetchPixels(t,e,s,i={}){const{rasters:r,rasterIds:o}=this.primaryRasters;let n=!1;const{interpolation:a}=i,l=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!i.requestRawData&&"bilinear"!==a&&l&&(n=1===r.length&&!i.skipRasterFunction,i={...i,interpolation:"bilinear",requestRawData:n});const m=r.map((r=>r.fetchPixels(t,e,s,i))),c=await Promise.all(m),p=c.map((t=>t.pixelBlock)),u=n||i.requestRawData?c.map((t=>t.srcTilePixelSize)):null;if(i.skipRasterFunction||p.every((t=>null==t)))return c[0];const h=c.find((t=>null!=t.pixelBlock))?.extent??t,d=this.rasterJobHandler?await this.rasterJobHandler.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o}):this.rasterFunction.process({extent:h,primaryPixelBlocks:p,primaryPixelSizes:u,primaryRasterIds:o}),{transformGrid:f}=c[0];if(!n||null==d||null==f)return{...c[0],pixelBlock:d};const y={rows:f.spacing[0],cols:f.spacing[1]};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[d],srcMosaicSize:{width:d.width,height:d.height},destDimension:{width:e,height:s},coefs:f.coefficients,sampleSpacing:y,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},i)).pixelBlock:A(d,{width:e,height:s},f.coefficients,y,a),{extent:t,srcExtent:c[0].srcExtent,pixelBlock:x}}_hasSameStorageInfo(t,e){const{storageInfo:s,pixelSize:i,spatialReference:r,extent:o}=t,{storageInfo:n,pixelSize:a,spatialReference:l,extent:m}=e;return i.x===a.x&&i.y===a.y&&r.equals(l)&&o.equals(m)&&s.blockHeight===n.blockHeight&&s.blockWidth===n.blockWidth&&s.maximumPyramidLevel===n.maximumPyramidLevel}};t([a({type:String,json:{write:!0}})],jt.prototype,"datasetFormat",void 0),t([a()],jt.prototype,"tileType",void 0),t([a()],jt.prototype,"rasterFunction",void 0),t([a()],jt.prototype,"primaryRasters",void 0),jt=t([c("esri.layers.support.rasterDatasets.FunctionRaster")],jt);const kt=jt,It=n.getLogger("esri.layers.mixins.ImageryTileMixin"),Rt=n=>{let j=class extends n{constructor(...t){super(...t),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalSubset=null,this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===t[0]?.raster?.datasetFormat}get fullExtent(){return this.rasterInfo?.extent}set multidimensionalDefinition(t){this._set("multidimensionalDefinition",t),this.updateRenderer()}set rasterFunction(t){"none"===t?.functionName?.toLowerCase()&&(t=void 0),this._set("rasterFunction",t),this.updateRasterFunction()}set url(t){this._set("url",h(t,It))}set renderer(t){null==t&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("renderer",t),this.updateRenderer())}readRenderer(t,e,s){const r=e?.layerDefinition?.drawingInfo?.renderer;return i(r,s)||void 0}async convertVectorFieldData(t,e){if(null==t||!this.rasterInfo)return null;const s=this._rasterJobHandler.instance,i=this.rasterInfo.dataType;return s?s.convertVectorFieldData({pixelBlock:t,dataType:i},e):q(t,i)}async computeStatisticsHistograms(t,e){t=l(ft,t).clone();const{rasterInfo:s}=this,{geometry:i}=t;if(null==i)throw new o("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let r=i;const{spatialReference:n}=s;i.spatialReference.equals(n)||(await G(),r="extent"===i.type?Y(i,n):it(i,n));const a=t.pixelSize??new ot({x:s.pixelSize.x,y:s.pixelSize.y,spatialReference:n}),{extent:m,width:c,height:u}=function(t,e,s,i=!0){const{spatialReference:r}=t,{x:o,y:n}=function(t,e){if(t.spatialReference.equals(e))return t;const s=p(t.spatialReference),i=p(e);if(s===i)return t;const r=s/i;return{x:t.x*r,y:t.y*r}}(s,r);let a,l,m;const c="extent"===e.type?e:e.extent;let{xmin:u,xmax:h,ymax:d,ymin:f}=c;const{xmin:y,ymax:x}=t.extent;return i?(u=y+(u>y?o*Math.round((u-y)/o):0),d=x-(d<x?n*Math.round((x-d)/n):0),h=y+(h>y?o*Math.round((h-y)/o):0),f=x-(f<x?n*Math.round((x-f)/n):0),a=new rt({xmin:u,ymax:d,xmax:h,ymin:f,spatialReference:r}),l=Math.round(a.width/o),m=Math.round(a.height/n)):(l=Math.floor((h-u)/o+.8),m=Math.floor((d-f)/n+.8),u=y+(u>y?o*Math.floor((u-y)/o+.1):0),d=x-(d<x?n*Math.floor((x-d)/n+.1):0),h=u+l*o,f=d-m*n,a=new rt({xmin:u,ymax:d,xmax:h,ymin:f,spatialReference:r})),{extent:a,width:l,height:m}}(s,r,a),h=await this.fetchPixels(m,c,u,{...e,interpolation:"nearest"});if(null==h.pixelBlock)throw new o("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const d=await async function(t,e,s){if("extent"===s.type)return function(t,e,s){const{width:i,height:r}=t,o=new Uint8Array(i*r),n=e.width/i,a=e.height/r;if(s.width/n<.5||s.height/a<.5)return new at({pixelType:t.pixelType,width:i,height:r,mask:o,pixels:[...t.pixels]});const{xmin:l,xmax:m,ymin:c,ymax:p}=e,{xmin:u,xmax:h,ymin:d,ymax:f}=s,y=Math.max(l,u),x=Math.min(m,h),g=Math.max(c,d),b=Math.min(p,f),j=.5*n,k=.5*a;if(x-y<j||b-g<k||x<l+j||y>m-j||g>p-k||b<c+k)return new at({pixelType:t.pixelType,width:i,height:r,mask:o,pixels:[...t.pixels]});const I=Math.max(0,(y-l)/n),R=Math.min(i,Math.max(0,(x-l)/n)),S=Math.max(0,(p-b)/a),w=Math.min(r,Math.max(0,(p-g)/a)),v=Math.round(I),T=Math.round(R)-1,M=Math.round(S),F=Math.round(w)-1;if(v===T&&I%1>.5&&R%1<.5||M===F&&S%1>.5&&w%1<.5)return new at({pixelType:t.pixelType,width:i,height:r,mask:o,pixels:[...t.pixels]});if(0===v&&0===M&&T===i&&F===r)return t;const _=t.mask;for(let t=M;t<=F;t++)for(let e=v;e<=T;e++){const s=t*i+e;o[s]=_?_[s]:255}return new at({pixelType:t.pixelType,width:i,height:r,mask:o,pixels:[...t.pixels]})}(t,e,s);const{width:i,height:r}=t,o=new Uint8Array(i*r),{contains:n,intersects:a}=await import("../../geometry/geometryEngine.js");return a(e,s)?"polyline"===s.type?function(t,e,s){const{width:i,height:r}=t,o=new Uint8Array(i*r),n=e.width/i,a=e.height/r,{xmin:l,ymax:m}=e,{paths:c}=s,p=t.mask;for(let t=0;t<c.length;t++){const e=c[t];for(let t=0;t<e.length-1;t++){const[s,c]=e[t],[u,h]=e[t+1];let d=Math.floor((m-c)/a),f=Math.floor((m-h)/a);if(f<d){const t=d;d=f,f=t}d=Math.max(0,d),f=Math.min(r-1,f);const y=(u-s)/(h-c);for(let t=d;t<=f;t++){const e=t===d?Math.max(c,h):(r+1-t)*a,m=t===f?Math.min(c,h):e-a;let x=h===c?Math.floor((s-l)/n):Math.floor((y*(e-c)+s-l)/n),g=h===c?Math.floor((u-l)/n):Math.floor((y*(m-c)+s-l)/n);if(g<x){const t=x;x=g,g=t}const b=t*i;x=Math.max(0,x),g=Math.min(i-1,g);for(let t=b+x;t<=b+g;t++)o[t]=p?p[t]:255}}}return new at({pixelType:t.pixelType,width:i,height:r,mask:o,pixels:[...t.pixels]})}(t,e,s):n(s,e)?t:function(t,e,s){if(!t)return t;const{width:i,height:r}=t,o=e.width/i,n=e.height/r,{xmin:a,ymax:l}=e;let m;if("extent"===s.type){const t=(s.xmin-a)/o,e=(s.xmax-a)/o,i=(l-s.ymax)/n,r=(l-s.ymin)/n;m=[[[t,i],[t,r],[e,r],[e,i],[t,i]]]}else m=s.rings.map((t=>t.map((([t,e])=>[(t-a)/o,(l-e)/n]))));const c=document.createElement("canvas");c.width=i,c.height=r;const p=c.getContext("2d");p.fillStyle="#f00",m.forEach((t=>{p.beginPath(),p.moveTo(t[0][0],t[0][1]);for(let e=0;e<t.length;e++)p.lineTo(t[e][0],t[e][1]);p.closePath(),p.fill()}));const u=p.getImageData(0,0,i,r).data,h=t.mask,d=i*r,f=new Uint8Array(d);for(let t=0;t<d;t++)h&&!h[t]||(f[t]=u[4*t+3]>127?255:0);return new at({pixelType:t.pixelType,width:i,height:r,mask:f,maskIsAlpha:!1,pixels:[...t.pixels]})}(t,e,s):new at({pixelType:t.pixelType,width:i,height:r,mask:o,maskIsAlpha:!1,pixels:[...t.pixels]})}(h.pixelBlock,m,r),f=this._rasterJobHandler.instance;return f?f.computeStatisticsHistograms({pixelBlock:d},e):mt(d)}async createFlowMesh(t,e){const s=this._rasterJobHandler.instance;return s?s.createFlowMesh(t,e):yt(t.meshType,t.simulationSettings,t.flowData,null!=e.signal?e.signal:(new AbortController).signal)}normalizeRasterFetchOptions(t){const{multidimensionalInfo:e}=this.rasterInfo??{};if(null==e)return t;let s=t.multidimensionalDefinition||this.multidimensionalDefinition;s?.length||(s=F(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const i=t.timeExtent||this.timeExtent;if(null!=s&&null!=i&&(null!=i.start||null!=i.end)){s=s.map((t=>t.clone()));const r=e.variables.find((({name:t})=>t===s[0].variableName))?.dimensions?.find((({name:t})=>"StdTime"===t)),o=s.find((({dimensionName:t})=>"StdTime"===t));if(!r||!o)return{...t,multidimensionalDefinition:null};const{start:n,end:a}=i,l=null==n?null:n.getTime(),m=null==a?null:a.getTime(),c=l??m,p=m??l;if(null!=r.values){const t=r.values.filter((t=>{if(Array.isArray(t)){if(c===p)return t[0]<=c&&t[1]>=c;const e=t[0]<=c&&t[1]>c||t[0]<p&&t[1]>=p,s=t[0]>=c&&t[1]<=p||t[0]<c&&t[1]>p;return e||s}return c===p?t===c:t>=c&&t<=p}));if(t.length){const e=t.sort(((t,e)=>{const s=Array.isArray(t)?t[0]:t,i=Array.isArray(t)?t[1]:t,r=Array.isArray(e)?e[0]:e,o=Array.isArray(e)?e[1]:e;return c===p?s-r:Math.abs(i-p)-Math.abs(o-p)}))[0];o.values=[e]}else s=null}else if(r.hasRegularIntervals&&r.extent){const[t,e]=r.extent;c>e||p<t?s=null:o.values=c===p?[c]:[Math.max(t,c),Math.min(e,p)]}}return null!=s&&_(s,this.multidimensionalSubset)?{...t,multidimensionalDefinition:null}:{...t,multidimensionalDefinition:s}}async updateRasterFunction(){if(!this.loaded||"imagery-tile"!==this.type||!this.rasterFunction&&!this._cachedRasterFunctionJson||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const t=this.raster.rasterFunction.toJSON();return!this.rasterFunction&&t&&this._set("rasterFunction",x.fromJSON(t)),void(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON())}let t,e=this.raster,s=!1;"Function"===e.datasetFormat?(t=e.primaryRasters.rasters,e=t[0],s=!0):t=[e];const{rasterFunction:i}=this;if(i){const s={raster:e};t.length>1&&t.forEach((t=>s[t.url]=t));const r=lt(i.functionDefinition?.toJSON()??i.toJSON(),s),o=new kt({rasterFunction:r});o.rasterJobHandler=this._rasterJobHandler.instance,await o.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=o}else this.raster=e,this._cachedRasterFunctionJson=null,await e.when();if(this._cachedRendererJson=null,!s&&!i)return;const{bandIds:r}=this,{bandCount:o}=this.raster.rasterInfo,n=r?.length?r.some((t=>t>=o)):o>=3;r&&(n||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}async updateRenderer(){const{loaded:t,symbolizer:e}=this;if(!t||!e||!this.renderer)return;const{rasterInfo:s}=this.raster,i=P(s,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=i?.name,o=ct({...this.renderer.toJSON(),variableName:r});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(o))return;const n=this._rasterJobHandler.instance;n&&(e.rasterInfo=pt(s,r),e.rendererJSON=o,e.bind(),await n.updateSymbolizer(e),this._cachedRendererJson=o)}async applyRenderer(t,e){const s=t?.pixelBlock;if(!(null!=s&&s.pixels&&s.pixels.length>0))return null;let i;await this.updateRenderer();const r=this._rasterJobHandler.instance,o=this.bandIds??[];return i=r?await r.symbolize({...t,simpleStretchParams:e,bandIds:o}):this.symbolizer.symbolize({...t,simpleStretchParams:e,bandIds:o}),i}getTileUrl(t,e,s){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${t}/${e}/${s}`:""}getCompatibleTileInfo(t,e,s=!1){if(!this.loaded||null==e)return null;if(s&&t.equals(this.spatialReference))return this.tileInfo;const i=u(t);return b.create({size:256,spatialReference:t,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:e.xmin,y:e.ymax}})}getCompatibleFullExtent(t){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(t)||(this._compatibleFullExtent=this.raster.computeExtent(t)),this._compatibleFullExtent):null}async fetchTile(t,e,s,i={}){if(k(this),i.requestAsImageElement){const o=this.getTileUrl(t,e,s);return r(o,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:i.signal}).then((t=>t.data))}const{rasterInfo:o}=this;if(null!=o.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition){const r=i.tileInfo||o.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(t,e,s,r),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(i={...i,buffer:{cols:1,rows:1}}),this.raster.fetchTile(t,e,s,i)}async fetchPixels(t,e,s,i={}){return null!=this.rasterInfo.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:t,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),e=Math.round(e),s=Math.round(s),this.raster.fetchPixels(t,e,s,i))}async identify(t,e={}){const{raster:s,rasterInfo:i}=this;if(null!=i.multidimensionalInfo&&!(i.hasMultidimensionalTranspose&&(w(e.multidimensionalDefinition)||e.transposedVariableName||e.timeExtent)||null!=(e=this.normalizeRasterFetchOptions(e)).multidimensionalDefinition))return{location:t,value:null};const r=this.multidimensionalSubset?.areaOfInterest;if(r&&!r.contains(t))throw new o("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return s.identify(t,e)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const t=this.rasterInfo?.multidimensionalInfo;if(null==t||"standard-time"!==this.rasterInfo?.dataType)return!1;const e=this.multidimensionalDefinition,s=e?.[0]?.variableName;return t.variables.some((t=>t.name===s&&(!e?.[0].dimensionName||t.dimensions.some((t=>"StdTime"===t.name)))))}getStandardTimeValue(t){return new Date(24*(t-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(t){const e=t??this.rasterInfo?.multidimensionalInfo;return D(this.multidimensionalSubset,e)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=F(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const t=new g;return this._rasterJobHandler.connectionPromise=t.initialize().then((async()=>{k(this),this._rasterJobHandler.instance=t,this.raster.rasterJobHandler=t,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){k(this);const{raster:t}=this,e=ut(t.rasterInfo,t.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(t="no"){k(this);const{rasterInfo:e}=this.raster;!this.bandIds&&e.bandCount>1&&(this.bandIds=ht(e));const s=P(e,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),i=s?.name;if(!this.renderer||"override"===t){const t=dt(e,{bandIds:this.bandIds,variableName:i}),s=e.statistics,r=s&&s.length>0?s[0]:null,o=r?.max??0,n=r?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&(o>1e24||n<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}const r=ct({...this.renderer.toJSON(),variableName:i}),o=pt(e,i);this.symbolizer?(this.symbolizer.rendererJSON=r,this.symbolizer.rasterInfo=o):this.symbolizer=new E({rendererJSON:r,rasterInfo:o});const n=this.symbolizer.bind();if(n.success){if("auto"===t){const{colormap:t}=this.raster.rasterInfo,e=this.renderer;if(null!=t&&"raster-colormap"===e.type){const t=dt(this.raster.rasterInfo);JSON.stringify(t)!==JSON.stringify(e)&&this._configDefaultRenderer("override")}else if("raster-stretch"===e.type){const t=this.bandIds?.length,s=e.statistics?.length;!e.dynamicRangeAdjustment&&s&&t&&s!==t&&this._configDefaultRenderer("override")}}}else It.warn("imagery-tile-mixin",n.error||"The given renderer is not supported by the layer."),"auto"===t&&this._configDefaultRenderer("override")}};function k(t){if(!t.raster||!t.rasterInfo)throw new o("imagery-tile","no raster")}return t([a({clonable:!1})],j.prototype,"_cachedRendererJson",void 0),t([a({clonable:!1})],j.prototype,"_cachedRasterFunctionJson",void 0),t([a({clonable:!1})],j.prototype,"_compatibleFullExtent",void 0),t([a({clonable:!1})],j.prototype,"_isConstructedFromFunctionRaster",void 0),t([a({clonable:!1})],j.prototype,"_rasterJobHandler",void 0),t([a()],j.prototype,"bandIds",void 0),t([a({json:{origins:{service:{read:{source:"copyrightText"}}}}})],j.prototype,"copyright",void 0),t([a({json:{read:!1}})],j.prototype,"fullExtent",null),t([a()],j.prototype,"interpolation",void 0),t([a()],j.prototype,"ioConfig",void 0),t([a({type:[f],json:{write:!0}})],j.prototype,"multidimensionalDefinition",null),t([a({type:y,json:{write:!0}})],j.prototype,"multidimensionalSubset",void 0),t([a()],j.prototype,"raster",void 0),t([a({type:x,json:{name:"renderingRule",write:!0}})],j.prototype,"rasterFunction",null),t([a()],j.prototype,"rasterInfo",void 0),t([a()],j.prototype,"sourceJSON",void 0),t([a({readOnly:!0,type:xt,json:{read:!1}})],j.prototype,"spatialReference",void 0),t([a({type:b})],j.prototype,"tileInfo",void 0),t([a(d)],j.prototype,"url",null),t([a({types:e,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const t="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!t}}},origins:{"web-scene":{types:s,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&"vector-field"!==t.type&&"flow"!==t.type})}}}}})],j.prototype,"renderer",null),t([m("renderer")],j.prototype,"readRenderer",null),t([a({clonable:!1})],j.prototype,"symbolizer",void 0),j=t([c("esri.layers.ImageryTileMixin")],j),j};export{bt as B,kt as F,Rt as ImageryTileMixin};
