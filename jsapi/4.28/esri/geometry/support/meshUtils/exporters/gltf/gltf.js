// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/Error ../../../../../core/Logger ../../../../../core/MapUtils ../../../../../core/mathUtils ../../../../../core/unitUtils ../../../../../chunks/mat4 ../../../../../chunks/mat4f64 ../../../../../chunks/quat ../../../../../chunks/quatf64 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../MeshGeoreferencedRelativeVertexSpace ../../../MeshGeoreferencedVertexSpace ../../../MeshMaterialMetallicRoughness ../../georeference ./buffer ./geometry ./types ./imageutils ../../../../../views/3d/glTF/internal/resourceUtils ../../../../../views/webgl/enums".split(" "),
function(H,P,Q,R,S,T,U,I,V,J,K,t,W,X,Y,L,M,N,k,C,D,l){const E=Q.getLogger("gltf");class Z{constructor(b,a,c){this.params={};this._materialMap=[];this._imageMap=new Map;this._textureMap=new Map;this.gltf={asset:{version:"2.0",copyright:b.copyright,generator:b.generator},extras:{options:a,binChunkBuffer:null,promises:[]}};c&&(this.params=c);this._addScenes(b)}_addScenes(b){this.gltf.scene=b.defaultScene;const a=this.gltf.extras,c=a.options.bufferOutputType===k.BufferOutputType.GLB||a.options.imageOutputType===
k.ImageOutputType.GLB;c&&(a.binChunkBuffer=new M.Buffer(this.gltf));b.forEachScene(e=>{this._addScene(e)});c&&a.binChunkBuffer.finalize()}_addScene(b){this.gltf.scenes||(this.gltf.scenes=[]);const a={};b.name&&(a.name=b.name);b.forEachNode(c=>{a.nodes||(a.nodes=[]);a.nodes.push(...this._addNodes(c))});this.gltf.scenes.push(a)}_addNodes(b){this.gltf.nodes||(this.gltf.nodes=[]);const a={};b.name&&(a.name=b.name);var c=b.translation;K.exactEquals(c,t.ZEROS)||(a.translation=t.clone(c));c=b.rotation;V.exactEquals(c,
J.IDENTITY)||(a.rotation=J.clone(c));c=b.scale;K.exactEquals(c,t.ONES)||(a.scale=t.clone(c));c=this.gltf.nodes.length;this.gltf.nodes.push(a);if(b.mesh&&b.mesh.vertexAttributes.position){b=this._createMeshes(b.mesh);c=[c];if(1===b.length)this._addMesh(a,b[0]);else for(const e of b)b={},this._addMesh(b,e),c.push(this.gltf.nodes.length),this.gltf.nodes.push(b);return c}b.forEachNode(e=>{a.children||(a.children=[]);a.children.push(...this._addNodes(e))});return[c]}_addMesh(b,a){var c;(c=this.gltf).meshes??
(c.meshes=[]);c=this.gltf.meshes.length;this.gltf.meshes.push(a);b.mesh=c}_createMeshes(b){var a=this.gltf.extras;const c=a.options.bufferOutputType===k.BufferOutputType.GLB;a=c?a.binChunkBuffer:new M.Buffer(this.gltf);this.params.origin||(this.params.origin=N.computeOrigin(b));var {ignoreLocalTransform:e}=this.params,g=e?null:b.transform;const {vertexSpace:m,spatialReference:r}=b;var d=b.vertexAttributes,f=null;switch(m.type){case "local":f=T.getMetersPerCartesianUnitForSR(r);U.scale(O,g?.localMatrix??
I.IDENTITY,[f,f,f]);f=L.applyTransform(d,O);break;default:f=e?m.isRelative?new W({origin:t.clone(m.origin)}):new X:m,f=L.ungeoreferenceByTransform(d,f,g,this.params.origin,{geographic:this.params.geographic,unit:"meters"})}if(null==f)throw new P("Error during gltf export.");d.position&&f.position===d.position&&(f.position=d.position.slice());d.normal&&f.normal===d.normal&&(f.normal=d.normal.slice());d.tangent&&f.tangent===d.tangent&&(f.tangent=d.tangent.slice());N.smoothNormals(b,f);this._flipYZAxis(f);
g=a.addBufferView(l.DataType.FLOAT,k.AttributeType.VEC3,k.TargetBuffer.ARRAY_BUFFER);let h;f.normal&&(h=a.addBufferView(l.DataType.FLOAT,k.AttributeType.VEC3,k.TargetBuffer.ARRAY_BUFFER));let n;d.uv&&(n=a.addBufferView(l.DataType.FLOAT,k.AttributeType.VEC2,k.TargetBuffer.ARRAY_BUFFER));let p;f.tangent&&(p=a.addBufferView(l.DataType.FLOAT,k.AttributeType.VEC4,k.TargetBuffer.ARRAY_BUFFER));let q;d.color&&(q=a.addBufferView(l.DataType.UNSIGNED_BYTE,k.AttributeType.VEC4,k.TargetBuffer.ARRAY_BUFFER));
g.startAccessor("POSITION");h&&h.startAccessor("NORMAL");n&&n.startAccessor("TEXCOORD_0");p&&p.startAccessor("TANGENT");q&&q.startAccessor("COLOR_0");e=f.position.length/3;const {position:F,normal:w,tangent:u}=f,{color:v,uv:G}=d;for(d=0;d<e;++d)g.push(F[3*d]),g.push(F[3*d+1]),g.push(F[3*d+2]),h&&null!=w&&(h.push(w[3*d]),h.push(w[3*d+1]),h.push(w[3*d+2])),n&&null!=G&&(n.push(G[2*d]),n.push(G[2*d+1])),p&&null!=u&&(p.push(u[4*d]),p.push(u[4*d+1]),p.push(u[4*d+2]),p.push(u[4*d+3])),q&&null!=v&&(q.push(v[4*
d]),q.push(v[4*d+1]),q.push(v[4*d+2]),q.push(v[4*d+3]));d=g.endAccessor();d=this._addAccessor(g.index,d);if(h){var x=h.endAccessor();x=this._addAccessor(h.index,x)}if(n){var y=n.endAccessor();y=this._addAccessor(n.index,y)}if(p){var z=p.endAccessor();z=this._addAccessor(p.index,z)}if(q){var A=q.endAccessor();A=this._addAccessor(q.index,A)}let B;f=[];b.components&&0<b.components.length&&b.components[0].faces?(B=a.addBufferView(l.DataType.UNSIGNED_INT,k.AttributeType.SCALAR,k.TargetBuffer.ELEMENT_ARRAY_BUFFER),
this._addMeshVertexIndexed(B,b.components,f,d,x,y,z,A)):this._addMeshVertexNonIndexed(b.components,f,d,x,y,z,A);g.finalize();h&&h.finalize();n&&n.finalize();p&&p.finalize();B&&B.finalize();q&&q.finalize();c||a.finalize();return f}_flipYZAxis({position:b,normal:a,tangent:c}){this._flipYZBuffer(b,3);this._flipYZBuffer(a,3);this._flipYZBuffer(c,4)}_flipYZBuffer(b,a){if(null!=b)for(let c=1,e=2;c<b.length;c+=a,e+=a){const g=b[c];b[c]=b[e];b[e]=-g}}_addMaterial(b){if(null!==b){var a=this._materialMap.indexOf(b);
if(-1!==a)return a;this.gltf.materials||(this.gltf.materials=[]);a={};switch(b.alphaMode){case "mask":a.alphaMode=k.AlphaMode.MASK;break;case "auto":case "blend":a.alphaMode=k.AlphaMode.BLEND}.5!==b.alphaCutoff&&(a.alphaCutoff=b.alphaCutoff);b.doubleSided&&(a.doubleSided=b.doubleSided);a.pbrMetallicRoughness={};var c=e=>{e=e.toRgba();e[0]=(e[0]/255)**2.1;e[1]=(e[1]/255)**2.1;e[2]=(e[2]/255)**2.1;return e};null!=b.color&&(a.pbrMetallicRoughness.baseColorFactor=c(b.color));null!=b.colorTexture&&(a.pbrMetallicRoughness.baseColorTexture=
this._createTextureInfo(b.colorTexture,b.colorTextureTransform));null!=b.normalTexture&&(a.normalTexture=this._createTextureInfo(b.normalTexture,b.normalTextureTransform));b instanceof Y?(null!=b.emissiveTexture&&(a.emissiveTexture=this._createTextureInfo(b.emissiveTexture,b.emissiveTextureTransform)),null!=b.emissiveColor&&(c=c(b.emissiveColor),a.emissiveFactor=[c[0],c[1],c[2]]),null!=b.occlusionTexture&&(a.occlusionTexture=this._createTextureInfo(b.occlusionTexture,b.occlusionTextureTransform)),
null!=b.metallicRoughnessTexture&&(a.pbrMetallicRoughness.metallicRoughnessTexture=this._createTextureInfo(b.metallicRoughnessTexture,b.metallicRoughnessTextureTransform)),a.pbrMetallicRoughness.metallicFactor=b.metallic,a.pbrMetallicRoughness.roughnessFactor=b.roughness):(a.pbrMetallicRoughness.metallicFactor=1,a.pbrMetallicRoughness.roughnessFactor=1,E.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back."));c=this.gltf.materials.length;
this.gltf.materials.push(a);this._materialMap.push(b);return c}}_createTextureInfo(b,a){b={index:this._addTexture(b)};if(!a)return b;b.extensions||(b.extensions={});b.extensions.KHR_texture_transform={scale:a.scale,offset:a.offset,rotation:S.deg2rad(a.rotation)};return b}_addTexture(b){const a=this.gltf.textures??[];this.gltf.textures=a;return R.getOrCreateMapValue(this._textureMap,b,()=>{const c={sampler:this._addSampler(b),source:this._addImage(b)},e=a.length;a.push(c);return e})}_addImage(b){var a=
this._imageMap.get(b);if(null!=a)return a;this.gltf.images||(this.gltf.images=[]);const c={};if(b.url)c.uri=b.url;else{a=b.data;c.extras=a;for(var e=0;e<this.gltf.images.length;++e)if(a===this.gltf.images[e].extras)return e;e=this.gltf.extras;switch(e.options.imageOutputType){case k.ImageOutputType.GLB:const g=e.binChunkBuffer.addBufferView(l.DataType.UNSIGNED_BYTE,k.AttributeType.SCALAR);D.isEncodedMeshTexture(a)?null!=a.data&&g.writeOutToBuffer(a.data,0):(a=C.imageToArrayBuffer(a).then(({data:m,
type:r})=>{c.mimeType=r;return m}),g.writeAsync(a).then(()=>{g.finalize()}));c.bufferView=g.index;break;case k.ImageOutputType.DataURI:D.isEncodedMeshTexture(a)?E.warnOnce("Image export for basis compressed textures not available."):c.uri=C.imageToDataURI(a);break;default:D.isEncodedMeshTexture(a)?E.warnOnce("Image export for basis compressed textures not available."):e.promises.push(C.imageToArrayBuffer(a).then(({data:m,type:r})=>{c.uri=m;c.mimeType=r}))}}a=this.gltf.images.length;this.gltf.images.push(c);
this._imageMap.set(b,a);return a}_addSampler(b){this.gltf.samplers||(this.gltf.samplers=[]);var a=l.TextureWrapMode.REPEAT;let c=l.TextureWrapMode.REPEAT;if("string"===typeof b.wrap)switch(b.wrap){case "clamp":c=a=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=a=l.TextureWrapMode.MIRRORED_REPEAT}else{switch(b.wrap.vertical){case "clamp":c=l.TextureWrapMode.CLAMP_TO_EDGE;break;case "mirror":c=l.TextureWrapMode.MIRRORED_REPEAT}switch(b.wrap.horizontal){case "clamp":a=l.TextureWrapMode.CLAMP_TO_EDGE;
break;case "mirror":a=l.TextureWrapMode.MIRRORED_REPEAT}}b={wrapS:a,wrapT:c};for(a=0;a<this.gltf.samplers.length;++a)if(JSON.stringify(b)===JSON.stringify(this.gltf.samplers[a]))return a;a=this.gltf.samplers.length;this.gltf.samplers.push(b);return a}_addAccessor(b,a){this.gltf.accessors||(this.gltf.accessors=[]);b={bufferView:b,byteOffset:a.byteOffset,componentType:a.componentType,count:a.count,type:a.type,min:a.min,max:a.max,name:a.name};a.normalized&&(b.normalized=!0);a=this.gltf.accessors.length;
this.gltf.accessors.push(b);return a}_addMeshVertexIndexed(b,a,c,e,g,m,r,d){const f=new Map;for(const h of a){b.startAccessor("INDICES");for(a=0;a<h.faces.length;++a)b.push(h.faces[a]);a=b.endAccessor();a={attributes:{POSITION:e},indices:this._addAccessor(b.index,a),material:this._addMaterial(h.material)};g&&"flat"!==h.shading&&(a.attributes.NORMAL=g);m&&(a.attributes.TEXCOORD_0=m);r&&"flat"!==h.shading&&(a.attributes.TANGENT=r);d&&(a.attributes.COLOR_0=d);const n=f.get(h.name);n?n.primitives.push(a):
(a={name:h.name,primitives:[a]},f.set(h.name,a),c.push(a))}}_addMeshVertexNonIndexed(b,a,c,e,g,m,r){const d={primitives:[]};a.push(d);a={attributes:{POSITION:c}};e&&(a.attributes.NORMAL=e);g&&(a.attributes.TEXCOORD_0=g);m&&(a.attributes.TANGENT=m);r&&(a.attributes.COLOR_0=r);b&&(a.material=this._addMaterial(b[0].material));d.primitives.push(a)}}const O=I.create();H.GLTF=Z;Object.defineProperty(H,Symbol.toStringTag,{value:"Module"})});