// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("../../../../core/ObjectPool ../../../../core/PooledArray ../../../../chunks/vec3 ../../../../chunks/vec3f64 ../../../../geometry/support/frustum ../../../../geometry/support/ray ../../../../chunks/sphere ./Util".split(" "),function(Y,E,w,m,H,R,l,S){function I(a,b,c){c[0]=a[0]+b;c[1]=a[1]+b;c[2]=a[2]+b}function T(a,b,c,d){if(1===b)a=c(a[0]),l.copy(a,d);else{r[0]=Infinity;r[1]=Infinity;r[2]=Infinity;t[0]=-Infinity;t[1]=-Infinity;t[2]=-Infinity;for(let g=0;g<b;g++){var f=c(a[g]);if(F(f[3])){var e=
r,h=f;e[0]=Math.min(e[0],h[0]-h[3]);e[1]=Math.min(e[1],h[1]-h[3]);e[2]=Math.min(e[2],h[2]-h[3]);e=t;e[0]=Math.max(e[0],f[0]+f[3]);e[1]=Math.max(e[1],f[1]+f[3]);e[2]=Math.max(e[2],f[2]+f[3])}}w.lerp(d,r,t,.5);d[3]=Math.max(t[0]-r[0],t[1]-r[1],t[2]-r[2])/2}}function Z(a,b,c){if(!B.length)for(var d=0;8>d;++d)B.push({index:0,distance:0});for(d=0;8>d;++d){const f=U[d];B.data[d].index=d;B.data[d].distance=z(a,b,f)}B.sort((f,e)=>f.distance-e.distance);for(a=0;8>a;++a)c[a]=B.data[a].index}function M(a,b){let c=
Infinity,d;for(let f=0;8>f;++f){const e=z(a,b,V[f]);e<c&&(c=e,d=V[f])}return d}function z(a,b,c){return b*(a[0]*c[0]+a[1]*c[1]+a[2]*c[2])}function F(a){return!isNaN(a)&&-Infinity!==a&&Infinity!==a&&0<a}class D{get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}constructor(a,b){this.objectToBoundingSphere=
a;this._maximumObjectsPerNode=10;this._maximumDepth=20;this._degenerateObjects=new Set;this._root=new k;this._objectCount=0;b&&(void 0!==b.maximumObjectsPerNode&&(this._maximumObjectsPerNode=b.maximumObjectsPerNode),void 0!==b.maximumDepth&&(this._maximumDepth=b.maximumDepth))}destroy(){this._degenerateObjects.clear();k.clearPool();N[0]=null;C.prune();B.prune()}add(a,b=a.length){this._objectCount+=b;this._grow(a,b);const c=k.acquire();for(let d=0;d<b;d++){const f=a[d];this._isDegenerate(f)?this._degenerateObjects.add(f):
(c.init(this._root),this._add(f,c))}k.release(c)}remove(a,b=null){this._objectCount-=a.length;const c=k.acquire();for(const d of a)a=null!=b?b:l.copy(this.objectToBoundingSphere(d),aa),F(a[3])?(c.init(this._root),this._remove(d,a,c)):this._degenerateObjects.delete(d);k.release(c);this._shrink()}update(a,b){if(F(b[3])||!this._isDegenerate(a))N[0]=a,a=N,this.remove(a,b),this.add(a)}forEachAlongRay(a,b,c){const d=R.wrap(a,b);this._forEachNode(this._root,f=>{if(!this._intersectsNode(d,f))return!1;f=f.node;
f.terminals.forAll(e=>{this._intersectsObject(d,e)&&c(e)});null!==f.residents&&f.residents.forAll(e=>{this._intersectsObject(d,e)&&c(e)});return!0})}forEachAlongRayWithVerticalOffset(a,b,c,d){const f=R.wrap(a,b);this._forEachNode(this._root,e=>{if(!this._intersectsNodeWithOffset(f,e,d))return!1;e=e.node;e.terminals.forAll(h=>{this._intersectsObjectWithOffset(f,h,d)&&c(h)});null!==e.residents&&e.residents.forAll(h=>{this._intersectsObjectWithOffset(f,h,d)&&c(h)});return!0})}forEach(a){this._forEachNode(this._root,
b=>{b=b.node;b.terminals.forAll(a);null!==b.residents&&b.residents.forAll(a);return!0});this._degenerateObjects.forEach(a)}forEachDegenerateObject(a){this._degenerateObjects.forEach(a)}findClosest(a,b,c,d=()=>!0,f=Infinity){let e=Infinity,h=Infinity,g=null;const p=M(a,b),x=q=>{--f;if(d(q)){var u=this.objectToBoundingSphere(q);if(H.intersectsSphere(c,u)){var J=z(a,b,l.getCenter(u)),G=J-u[3];u=J+u[3];G<e&&(e=G,h=u,g=q)}}};this._forEachNodeDepthOrdered(this._root,q=>{if(0>=f||!H.intersectsSphere(c,q.bounds))return!1;
w.scale(v,p,q.halfSize);w.add(v,v,q.bounds);if(z(a,b,v)>h)return!1;q=q.node;q.terminals.forAll(u=>x(u));null!==q.residents&&q.residents.forAll(u=>x(u));return!0},a,b);return g}forEachInDepthRange(a,b,c,d,f,e,h){let g=-Infinity,p=Infinity;const x={setRange:n=>{c===D.DepthOrder.FRONT_TO_BACK?(g=Math.max(g,n.near),p=Math.min(p,n.far)):(g=Math.max(g,-n.far),p=Math.min(p,-n.near))}};x.setRange(d);const q=z(b,c,a),u=M(b,c),J=M(b,-c),G=n=>{if(h(n)){var A=this.objectToBoundingSphere(n),K=l.getCenter(A);K=
z(b,c,K)-q;var ba=K+A[3];K-A[3]>p||ba<g||!H.intersectsSphere(e,A)||f(n,x)}};this._forEachNodeDepthOrdered(this._root,n=>{if(!H.intersectsSphere(e,n.bounds))return!1;w.scale(v,u,n.halfSize);w.add(v,v,n.bounds);if(z(b,c,v)-q>p)return!1;w.scale(v,J,n.halfSize);w.add(v,v,n.bounds);if(z(b,c,v)-q<g)return!1;n=n.node;n.terminals.forAll(A=>G(A));null!==n.residents&&n.residents.forAll(A=>G(A));return!0},b,c)}forEachNode(a){this._forEachNode(this._root,b=>a(b.node,b.bounds,b.halfSize,b.depth))}forEachNeighbor(a,
b){const c=l.getRadius(b),d=l.getCenter(b),f=g=>{const p=this.objectToBoundingSphere(g);var x=l.getRadius(p);x=c+x;return 0>=w.squaredDistance(l.getCenter(p),d)-x*x?a(g):!0};let e=!0;const h=g=>{e&&(e=f(g))};this._forEachNode(this._root,g=>{var p=l.getRadius(g.bounds);p=c+p;if(0<w.squaredDistance(l.getCenter(g.bounds),d)-p*p)return!1;g=g.node;g.terminals.forAll(h);e&&null!==g.residents&&g.residents.forAll(h);return e});e&&this.forEachDegenerateObject(h)}_intersectsNode(a,b){I(b.bounds,2*-b.halfSize,
r);I(b.bounds,2*b.halfSize,t);return S.rayBoxTest(a.origin,a.direction,r,t)}_intersectsNodeWithOffset(a,b,c){I(b.bounds,2*-b.halfSize,r);I(b.bounds,2*b.halfSize,t);c.applyToMinMax(r,t);return S.rayBoxTest(a.origin,a.direction,r,t)}_intersectsObject(a,b){b=this.objectToBoundingSphere(b);return 0<b[3]?l.intersectsRay(b,a):!0}_intersectsObjectWithOffset(a,b,c){b=this.objectToBoundingSphere(b);return 0<b[3]?l.intersectsRay(c.applyToBoundingSphere(b),a):!0}_forEachNode(a,b){a=k.acquire().init(a);const c=
[a];for(;0!==c.length;){a=c.pop();if(b(a)&&!a.isLeaf())for(let d=0;d<a.node.children.length;d++)a.node.children[d]&&c.push(k.acquire().init(a).advance(d));k.release(a)}}_forEachNodeDepthOrdered(a,b,c,d=D.DepthOrder.FRONT_TO_BACK){a=k.acquire().init(a);const f=[a];for(Z(c,d,W);0!==f.length;){a=f.pop();if(b(a)&&!a.isLeaf())for(c=7;0<=c;--c)d=W[c],a.node.children[d]&&f.push(k.acquire().init(a).advance(d));k.release(a)}}_remove(a,b,c){C.clear();b=c.advanceTo(b,(d,f)=>{C.push(d.node);C.push(f)})?c.node.terminals:
c.node.residents;b.removeUnordered(a);if(0===b.length)for(a=C.length-2;0<=a&&this._purge(C.data[a],C.data[a+1]);a-=2);}_nodeIsEmpty(a){if(0!==a.terminals.length)return!1;if(null!==a.residents)return 0===a.residents.length;for(let b=0;b<a.children.length;b++)if(a.children[b])return!1;return!0}_purge(a,b){0<=b&&(a.children[b]=null);return this._nodeIsEmpty(a)?(null===a.residents&&(a.residents=new E({shrink:!0})),!0):!1}_add(a,b){b.advanceTo(this.objectToBoundingSphere(a))?b.node.terminals.push(a):(b.node.residents.push(a),
b.node.residents.length>this._maximumObjectsPerNode&&b.depth<this._maximumDepth&&this._split(b))}_split(a){const b=a.node.residents;a.node.residents=null;for(let c=0;c<b.length;c++){const d=k.acquire().init(a);this._add(b.at(c),d);k.release(d)}}_grow(a,b){0!==b&&(T(a,b,c=>this.objectToBoundingSphere(c),y),F(y[3])&&!this._fitsInsideTree(y)&&(this._nodeIsEmpty(this._root.node)?(l.copy(y,this._root.bounds),this._root.halfSize=1.25*this._root.bounds[3],this._root.updateBoundsRadiusFromHalfSize()):(a=
this._rootBoundsForRootAsSubNode(y),this._placingRootViolatesMaxDepth(a)?this._rebuildTree(y,a):this._growRootAsSubNode(a),k.release(a))))}_rebuildTree(a,b){w.copy(O,b.bounds);O[3]=b.halfSize;T([a,O],2,c=>c,P);a=k.acquire().init(this._root);this._root.initFrom(null,P,P[3]);this._root.increaseHalfSize(1.25);this._forEachNode(a,c=>{this.add(c.node.terminals.data,c.node.terminals.length);null!==c.node.residents&&this.add(c.node.residents.data,c.node.residents.length);return!0});k.release(a)}_placingRootViolatesMaxDepth(a){const b=
Math.log(a.halfSize/this._root.halfSize)*Math.LOG2E;let c=0;this._forEachNode(this._root,d=>{c=Math.max(c,d.depth);return c+b<=this._maximumDepth});return c+b>this._maximumDepth}_rootBoundsForRootAsSubNode(a){var b=a[3],c=-Infinity;const d=this._root.bounds,f=this._root.halfSize;for(var e=0;3>e;e++){var h=Math.max(0,Math.ceil((d[e]-f-(a[e]-b))/(2*f)));const g=Math.max(0,Math.ceil((a[e]+b-(d[e]+f))/(2*f)))+1;c=Math.max(c,2**Math.ceil(Math.log(h+g)*Math.LOG2E));L[e].min=h;L[e].max=g}for(a=0;3>a;a++)b=
L[a].min,e=L[a].max,h=(c-(b+e))/2,b+=Math.ceil(h),e+=Math.floor(h),Q[a]=d[a]-f-b*f*2+(e+b)*f;c*=f;Q[3]=c*X;return k.acquire().initFrom(null,Q,c,0)}_growRootAsSubNode(a){const b=this._root.node;w.copy(y,this._root.bounds);y[3]=this._root.halfSize;this._root.init(a);a.advanceTo(y,null,!0);a.node.children=b.children;a.node.residents=b.residents;a.node.terminals=b.terminals}_shrink(){for(;;){const a=this._findShrinkIndex();if(-1===a)break;this._root.advance(a);this._root.depth=0}}_findShrinkIndex(){if(0!==
this._root.node.terminals.length||this._root.isLeaf())return-1;let a=null;const b=this._root.node.children;let c=0,d=0;for(;d<b.length&&null==a;)c=d++,a=b[c];for(;d<b.length;)if(b[d++])return-1;return c}_isDegenerate(a){a=this.objectToBoundingSphere(a)[3];return!F(a)}_fitsInsideTree(a){const b=this._root.bounds,c=this._root.halfSize;return a[3]<=c&&a[0]>=b[0]-c&&a[0]<=b[0]+c&&a[1]>=b[1]-c&&a[1]<=b[1]+c&&a[2]>=b[2]-c&&a[2]<=b[2]+c}toJSON(){const {maximumDepth:a,maximumObjectsPerNode:b,_objectCount:c}=
this,d=this._nodeToJSON(this._root.node);return{maximumDepth:a,maximumObjectsPerNode:b,objectCount:c,root:{bounds:this._root.bounds,halfSize:this._root.halfSize,depth:this._root.depth,node:d}}}_nodeToJSON(a){const b=a.children.map(d=>d?this._nodeToJSON(d):null),c=a.residents?.map(d=>this.objectToBoundingSphere(d));a=a.terminals?.map(d=>this.objectToBoundingSphere(d));return{children:b,residents:c,terminals:a}}static fromJSON(a){const b=new D(c=>c,{maximumDepth:a.maximumDepth,maximumObjectsPerNode:a.maximumObjectsPerNode});
b._objectCount=a.objectCount;b._root.initFrom(a.root.node,a.root.bounds,a.root.halfSize,a.root.depth);return b}}class k{constructor(){this.bounds=l.create();this.halfSize=0;this.initFrom(null,null,0,0)}init(a){return this.initFrom(a.node,a.bounds,a.halfSize,a.depth)}initFrom(a,b,c,d=this.depth){this.node=null!=a?a:k.createEmptyNode();null!=b&&l.copy(b,this.bounds);this.halfSize=c;this.depth=d;return this}increaseHalfSize(a){this.halfSize*=a;this.updateBoundsRadiusFromHalfSize()}updateBoundsRadiusFromHalfSize(){this.bounds[3]=
this.halfSize*X}advance(a){let b=this.node.children[a];b||(b=k.createEmptyNode(),this.node.children[a]=b);this.node=b;this.halfSize/=2;this.depth++;a=U[a];this.bounds[0]+=a[0]*this.halfSize;this.bounds[1]+=a[1]*this.halfSize;this.bounds[2]+=a[2]*this.halfSize;this.updateBoundsRadiusFromHalfSize();return this}advanceTo(a,b,c=!1){for(;;){if(this.isTerminalFor(a))return b&&b(this,-1),!0;if(this.isLeaf()){if(!c)return b&&b(this,-1),!1;this.node.residents=null}const d=this._childIndex(a);b&&b(this,d);
this.advance(d)}}isLeaf(){return null!=this.node.residents}isTerminalFor(a){return a[3]>this.halfSize/2}_childIndex(a){const b=this.bounds;return(b[0]<a[0]?1:0)+(b[1]<a[1]?2:0)+(b[2]<a[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new E({shrink:!0}),residents:new E({shrink:!0})}}static acquire(){return k._pool.acquire()}static release(a){k._pool.release(a)}static clearPool(){k._pool.prune()}}k._pool=new Y(k);(function(a){a=a.DepthOrder||(a.DepthOrder=
{});a[a.FRONT_TO_BACK=1]="FRONT_TO_BACK";a[a.BACK_TO_FRONT=-1]="BACK_TO_FRONT"})(D||(D={}));const U=[m.fromValues(-1,-1,-1),m.fromValues(1,-1,-1),m.fromValues(-1,1,-1),m.fromValues(1,1,-1),m.fromValues(-1,-1,1),m.fromValues(1,-1,1),m.fromValues(-1,1,1),m.fromValues(1,1,1)],V=[m.fromValues(-1,-1,-1),m.fromValues(-1,-1,1),m.fromValues(-1,1,-1),m.fromValues(-1,1,1),m.fromValues(1,-1,-1),m.fromValues(1,-1,1),m.fromValues(1,1,-1),m.fromValues(1,1,1)],X=Math.sqrt(3),N=[null],Q=l.create(),v=m.create(),r=
m.create(),t=m.create(),C=new E,aa=l.create(),y=l.create(),O=l.create(),P=l.create(),L=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],B=new E,W=[0,0,0,0,0,0,0,0];return D});