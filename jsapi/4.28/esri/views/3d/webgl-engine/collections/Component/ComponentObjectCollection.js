// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../../core/has ../../../../../core/Logger ../../../../../core/PooledArray ../../../../../core/typedArrayUtil ../../../../../chunks/mat3 ../../../../../chunks/mat3f32 ../../../../../chunks/vec3 ../../../../../chunks/vec3f64 ../../../../../geometry/support/Indices ../../../../../chunks/vec32 ../../../../../chunks/vec33 ../../../../ViewingMode ../../../layers/support/symbolColorUtils ../../../support/orientedBoundingBox ../../../support/buffer/glUtil ../../../support/buffer/InterleavedLayout ./ComponentData ./ComponentObject ./IntersectionGeometry ./Renderable ./RenderGeometry ./RenderSubmitSystem ./SourceGeometry ./UniformComponentParameters ./Material/ComponentMaterial ./Material/ComponentTechnique ./Material/shader/ComponentData.glsl ../../lib/ComponentUtils ../../lib/Util ../../lib/VertexAttribute ../../lib/verticalOffsetUtils ../../lib/edgeRendering/bufferLayouts ../../lib/edgeRendering/edgeProcessing ../../lib/TextureBackedBuffer/BufferManager ../../../../webgl/BufferObject ../../../../webgl/enums ../../../../webgl/VertexArrayObject".split(" "),
function(H,Q,R,I,S,J,T,t,B,U,V,W,X,K,w,L,Y,Z,x,aa,ba,ca,da,ea,fa,n,ha,ia,M,ja,ka,la,ma,na,oa,C,y,pa){function D(a,b){return a===b?n.ComponentParameterSummary.All:0===a?n.ComponentParameterSummary.None:n.ComponentParameterSummary.Some}const N=R.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class qa{constructor(a,b){this._renderManager=a;this._viewingMode=b;this._objects=[new I,new I];this._renderSubmit=new da.RenderSubmitSystem(this);this._renderManager.register(this._renderSubmit);
this._hasObjectAndLayerId=Q("enable-feature:objectAndLayerId-rendering");this._componentBufferManager=new oa.BufferManager(a.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){ja.assert(0===this._objects[x.State.Hidden].length&&0===this._objects[x.State.Visible].length,"ObjectCollection should be empty upon disposal");this._componentBufferManager.destroy();const a=this._objects.flatMap(b=>b.toArray());for(const b of a)b?.destroy()}createObject(a){const b=new x.ComponentObject;b.toMapSpace=a.toMapSpace;
b.transform=a.transform;b.obb=w.clone(a.obb);b.components=new Z(this._componentBufferManager,U.compactIndices(a.geometry.componentOffsets));b.renderable=this._createRenderable(a,b.components);b.intersectionGeometry=new aa(a.geometry.positionData,b.components);this._objects[b.visible].push(b);return b}destroyObject(a){this._objects[a.visible].removeUnordered(a);a.destroy();this._notifyDirty()}setObjectVisibility(a,b){b!==a.visible&&(this._objects[a.visible].removeUnordered(a),this._objects[b].push(a),
a.visible=b,this._notifyDirty())}preSubmit(a){const b=a.camera.eye;this.visibleObjects.forAll(c=>c.renderable.meta.cameraDepthSquared=t.squaredDistance(b,c.obb.center))}getMaterial(a){return a.renderable.material}updateMaterial(a,b){a=a.renderable.material;b(a);a.dirty&&this._notifyDirty()}setAllComponentVisibilities(a,b){a.components.visibility.reset(b);a.components.visibilityDirty();this._notifyDirty()}forEachVisibleComponent(a,b){return a.components.visibility.forEachComponent(b)}getComponentCount(a){const b=
a.components.visibility.componentCount();return{visible:b,invisible:a.components.count-b}}setComponentData(a,b){const c=a.renderable.material,d=a.components;var f=d.materialDataBuffer;const h=d.materialDataIndices,e=new fa.UniformComponentParameters;f=f.textureBuffer;const g=new Uint8Array(4),k=new Uint32Array(g.buffer);let m=0,p=0,u=0,q=d.verticalOffsets,E=Infinity,F=-Infinity,G=!1,r=!1,O=0;for(let l=0;l<d.count;l++){b(l,e);m+=+(1>e.externalColor[3]);p+=+(e.externalColorMixMode===K.ColorMixModeEnum.Replace&&
1===e.externalColor[3]);u+=+e.castShadows;K.encodeSymbolColor(e.externalColor,e.externalColorMixMode,g);g[2]=g[2]&254|+e.castShadows;f.setData(h[l],0,g[0],g[1],g[2],g[3]);G||(G=0<l&&O!==k[0]);O=k[0];r||(r=0!==e.elevationOffset);r&&null==q&&(q=Array(l).fill(0));null!=q&&(q[l]=e.elevationOffset);E=Math.min(E,e.elevationOffset);F=Math.max(F,e.elevationOffset);ia.encodeElevationOffset(e.elevationOffset,g);f.setData(h[l],1,g[0],g[1],g[2],g[3]);const v=e.objectAndLayerIdColor;null!=v&&f.setData(h[l],2,
v[0],v[1],v[2],v[3]);e.pickable!==M.getVisibility(d.pickability,l)&&(d.pickability=M.updateVisibilityWithCount(d.pickability,d.count,l,e.pickable))}d.verticalOffsets=r?q:null;a.offsetObb=r?w.computeOffsetObb(a.obb,E,F,this._viewingMode,null!=a.offsetObb?a.offsetObb:w.clone(a.obb)):null;G||r||this._hasObjectAndLayerId?(c.componentParameters=new n.ComponentParametersVarying,c.componentParameters.castShadows=D(u,d.count),c.componentParameters.transparent=D(m,d.count),c.componentParameters.opaqueOverride=
D(p,d.count),c.componentParameters.texture=f,f.updateTexture()):(c.componentParameters=new n.ComponentParametersUniform,c.componentParameters.castShadows=e.castShadows?n.ComponentParameterSummary.All:n.ComponentParameterSummary.None,c.componentParameters.externalColor=e.externalColor,c.componentParameters.externalColorMixMode=e.externalColorMixMode);this._notifyDirty()}getComponentAabb(a,b,c,d=!1){a.intersectionGeometry.getComponentAabb(b,c);const f=a.components.verticalOffsets;if(d||null==f)return c;
b=f[b];if(this._viewingMode===X.ViewingMode.Local||0===b)return c[2]+=b,c[5]+=b,c;b=la.getVerticalOffsetI3S(b);b.localOrigin=a.transform.position;return b.applyToAabb(c)}getComponentObb(a){return a.obb}getObjectTransform(a){return a.transform}getComponentPositions(a,b,c){return a.intersectionGeometry.getComponentPositions(b,c)}intersect(a,b,c,d,f,h){null!=f&&(f.localOrigin=a.transform.position);const e=J.invert(P,a.transform.rotationScale);t.sub(z,b,a.transform.position);t.sub(A,c,a.transform.position);
t.transformMat3(z,z,e);t.transformMat3(A,A,e);b=J.transpose(P,e);return a.intersectionGeometry.intersect(z,A,d,b,f,a.components.verticalOffsets,h)}addEdges(a,b,c,d){const {indices:f,positions:h}=a.intersectionGeometry,e=a.components.offsets;return b.addComponentObject(a,a.transform,{center:a.obb.center,radius:w.radius(a.obb)},h,f,e,c,d)}async extractEdgeInformation(a,b,c){var d=a.components.visibility;if(d.allInvisible())return{buffer:na.extractComponentsEdgeLocationsLayout.createBuffer(0),origin:[0,
0,0]};const {indices:f,positions:h}=a.intersectionGeometry,e=a.components.offsets,g=ma.EdgeInputBufferLayout.createBuffer(h.length/3);W.copy(g.position.typedBuffer,h,g.position.typedBufferStride,3);V.transformMat3View(g.position,g.position,a.transform.rotationScale);this._setComponentIndices(g.componentIndex,f,e);d=this._computeVisibilityIndices(f,d,e,g.count);a=B.clone(a.transform.position);b=await b.extractComponentsEdgeLocations({indices:d,indicesLength:d.length,skipDeduplicate:!0,data:g,writerSettings:{reducedPrecision:!1,
variants:0}},c);return{origin:a,buffer:b}}_setComponentIndices(a,b,c){let d=0;for(let h=0;h<c.length-1;h++){var f=c[h];const e=c[h+1];for(;f<e;f++)a.set(b?b[f]:f,d);d++}}_computeVisibilityIndices(a,b,c,d){if(a&&b.allVisible())return a;let f=0;b.forEachComponentRange((g,k)=>{f+=c[k]-c[g];return!0});const h=S.isArray(a)?Array(f):2===a?.BYTES_PER_ELEMENT||65536>=d?new Uint16Array(f):new Uint32Array(f);let e=0;b.forEachComponentRange((g,k)=>{g=c[g];for(k=c[k];g<k;g++)h[e++]=a?a[g]:g;return!0});return h}addComponentHighlight(a,
b){a=a.components;null==a.highlightCounts&&(a.highlightCounts=new Uint32Array(a.count+1));0===a.highlightCounts[b]++&&(a.highlightsDirty(),this._notifyDirty());a.highlightCounts[a.count]++}removeComponentHighlight(a,b){a=a.components;if(null==a.highlightCounts)N.warn("Removing non-existing highlight.");else{var c=a.highlightCounts[b],d=a.highlightCounts[a.count];0===c?N.warn("Removing non-existing highlight."):1<c?(a.highlightCounts[b]=c-1,a.highlightCounts[a.count]=d-1):(a.highlightCounts[b]=0,a.highlightsDirty(),
this._notifyDirty(),1===d?a.highlightCounts=null:a.highlightCounts[a.count]=d-1)}}clearHighlights(a){a=a.components;null!=a.highlightCounts&&(a.highlightCounts=null,a.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(a){return a.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[x.State.Visible]}_createRenderable(a,b){var c=this._renderManager.rctx;const d=a.geometry;var f=d.vertices.layoutParameters;const h=C.BufferObject.createVertex(c,y.Usage.STATIC_DRAW,d.vertices.data),
e=d.indices?C.BufferObject.createIndex(c,y.Usage.STATIC_DRAW,d.indices):null,g=L.glLayout(ea.createVertexBufferLayout(f)),k=new Uint16Array(d.vertices.count);for(let p=0;p<b.count;p++){var m=b.offsets[p];const u=b.offsets[p+1],q=b.materialDataIndices[p];if(null!=d.indices)for(;m<u;m++)k[d.indices[m]]=q;else for(;m<u;m++)k[m]=q}b=C.BufferObject.createVertex(c,y.Usage.STATIC_DRAW,k.buffer);a=new n.ComponentMaterial(a.transform,a.toMapSpace);c=new pa.VertexArrayObject(c,ha.attributeLocations,{data:g,
componentIndices:ra},{data:h,componentIndices:b},e);f=new ca.RenderGeometry(c,y.PrimitiveType.TRIANGLES,f,null!=e);return new ba.Renderable(a,f,{cameraDepthSquared:.5,gpuMemoryEstimate:h.byteLength+b.byteLength+(null!=e?e.byteLength:0)})}_notifyDirty(){this._renderManager.notifyDirty()}}const ra=L.glLayout(Y.newLayout().u16(ka.VertexAttribute.COMPONENTINDEX)),P=T.create(),z=B.create(),A=B.create();H.ComponentObjectCollection=qa;Object.defineProperty(H,Symbol.toStringTag,{value:"Module"})});