// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("../../../../core/asyncUtils ../../../../core/has ../../../../core/lang ../../../../core/promiseUtils ../../../../core/urlUtils ./enums ./I3SBinaryReader ./I3SMaterialUtil".split(" "),function(q,z,A,B,w,t,x,u){class v{constructor(a,b,f,c,d,e){this._streamDataController=b;this._logger=f;this._defaultGeometrySchema=c;this._requiredAttributes=d;this._options=e;this._logLayer=a;this._layerUrl=a.parsedUrl.path;this._geometryDefinitions=a.geometryDefinitions;if(a.materialDefinitions){const g=a.textureSetDefinitions;
this._materialAndTextures=a.materialDefinitions.map(h=>u.getMaterialAndTextures(g,h))}}_load(a,b,f){return this._streamDataController.request(a,b,f)}_loadAttribute(a,b,f){return this._load(`${this._layerUrl}/nodes/${a.resources.attributes}/attributes/${b.key}/0`,"binary",f).then(c=>x.readBinaryAttribute(b,c))}async loadAttributes(a,b,f){const c=await Promise.allSettled(b.map(g=>this._loadAttribute(a,g.attributeStorageInfo,f))),d={};for(let g=0;g<b.length;++g){var e=c[g];const h=b[g];"fulfilled"===
e.status?d[h.name]=e.value:(e=e.reason,B.throwIfAbortError(e),this._logger.error("#loadAttributes",this._logLayer,`Failed to load attributeData for '${h.name}' on node '${a.id}'`,e))}return d}async loadNodeData(a,b){var f=null!=this._requiredAttributes&&a.resources.attributes?q.result(this.loadAttributes(a,this._requiredAttributes,b)):null;var c=this._geometryDefinitions;var d={bufferDefinition:null,bufferIndex:0};var e=a.resources.geometryDefinition;if(!(null==c||null==e||0>e)&&(c=0<=e?c[e].geometryBuffers:
null,null!=c))for(e=0;e<c.length;e++){var g=c[e];if(null!=g.compressedAttributes){if("draco"===g.compressedAttributes.encoding&&!z("disable-feature:i3s-draco")){d.bufferIndex=e;d.bufferDefinition=g;break}}else d.bufferIndex=e,d.bufferDefinition=c[e]}const {bufferDefinition:h,bufferIndex:m}=d;e=(g=!!a.resources.geometry)?q.result(this._loadGeometry(a.resources.geometry,m,b)):null;c=a.resources.hasSharedResource?await this._loadShared(a,b):null;d=a.resources.materialDefinition;d=this._materialAndTextures&&
null!=d&&0<=d?this._materialAndTextures[d]:null!=c?u.getMaterialAndTexturesFromShared(c):null;var n=d?.material;d=d?.textures??[];const r=`${a.id}`,y=!g&&this._options.loadFeatureData;g=y?await this._loadFeatureData(r,b):null;if(y)a:{if(g)for(k of g.featureData)if(n=k.geometries,null!=n)for(var p of n){var k={featureIds:[k.id],featureDataPosition:k.position,geometries:[p]};break a}k=null}else k={featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:n}}],featureDataPosition:[0,0,0]};if(null==
k)if(g){p=[];for(l of g.featureData)null!=l.position&&p.push({featureIds:[l.id],featureDataPosition:l.position,geometries:[]});var l=p}else l=null;else l=null;p=0<d.length?q.result(this.loadTextures(a,d,b)):null;b=a=null;e&&(a=q.assertResult(await e),(b=this._defaultGeometrySchema)&&c?.materialDefinitions&&(e=Object.keys(c.materialDefinitions)[0],!c.materialDefinitions[e].params.vertexRegions&&b.vertexAttributes.region&&(b=A.clone(b),delete b.vertexAttributes.region)),b=x.createGeometryDescriptor(h,
b));c=p?q.assertResult(await p):null;f=(f=f?q.assertResult(await f):{})?{attributeData:f,loadedAttributes:this._requiredAttributes}:null;if(null!=k)return{geometryData:k,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};if(null!=l)return{pointData:l,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:b,requiredTextures:d,textureData:c};throw Error();}static _addAbsoluteHrefTexture(a,b){a=a.textureDefinitions;if(null!=a)for(const f of Object.keys(a))for(const c of a[f].images)Array.isArray(c.href)?
c.hrefConcat=c.href.map(d=>w.makeAbsolute(d,b)):c.hrefConcat=w.makeAbsolute(c.href,b)}static _fixTextureEncodings(a){a=a.textureDefinitions;if(null!=a)for(const f in a){const c=a[f];if(Array.isArray(c.encoding))for(var b=0;b<c.encoding.length;b++){const d=c.encoding[b];"data:"===d.substring(0,5)&&(c.encoding[b]=d.substring(5))}else b=c.encoding,"data:"===b.substring(0,5)&&(c.encoding=b.substring(5))}}_loadShared(a,b){const f=`${this._layerUrl}/nodes/${a.resources.geometry}/shared`;return this._load(f,
"json",b).then(c=>{v._fixTextureEncodings(c);v._addAbsoluteHrefTexture(c,f);return c})}_loadTexture(a,b,f,c,d,e){let g=!1;return d===t.TextureEncoding.DDS_S3TC||d===t.TextureEncoding.KTX2||d===t.TextureEncoding.Basis?this._load(a,"binary",e).then(h=>({id:b,usage:f,data:h,encoding:d,downsampled:g})):this._load(a,"image",e).then(h=>{var m=h;if(c&&4096<=h.width*h.height){m=Math.ceil(h.width/2);const n=Math.ceil(h.height/2),r=document.createElement("canvas");r.width=m;r.height=n;r.getContext("2d").drawImage(h,
0,0,m,n);m=r;g=!0}return{id:b,usage:f,data:m,encoding:d,downsampled:g}})}loadTextures(a,b,f){const c=!!this._options.uncompressedTextureDownsamplingEnabled,d=this._options.textureUsageMask;return Promise.all(b.map(e=>{if(0===(e.usage&d))return null;const g=u.selectEncoding(e.encodings,this._options.textureEncodings);return null==g?(this._logger.error("#loadTextures",this._logLayer,`No known encoding for texture found on node ${a.id}`),Promise.reject()):this._loadTexture(`${this._layerUrl}/nodes/${a.resources.texture||
a.id}/textures/${g.name}`,e.id,e.usage,c,g.encoding,f)}))}_loadFeatureData(a,b){return this._load(`${this._layerUrl}/nodes/${a}/features/0`,"json",b)}_loadGeometry(a,b,f){return this._load(`${this._layerUrl}/nodes/${a}/geometries/${b}`,"binary",f)}}return v});