// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../core/mathUtils ../../../chunks/vec3 ../../../chunks/vec3f64 ../../../geometry/projection/lonLatToSphericalPCPF ../../../geometry/support/DoubleArray ../../../geometry/support/frustum ../../../chunks/sphere ./interfaces ./ITile ./PatchGeometryFactory ./terrainUtils ./Tile ./tileUtils".split(" "),function(ba,ca,g,m,na,oa,Z,pa,R,U,aa,A,N,qa){function da(b,a,d,e,c,f){b=e-b;a=c-a;d=f-d;return b*b+a*a+d*d}class ra extends N.Tile{constructor(b,a,d,e,c){super();this._convexHull=Array(24);
this._boundingSphere=pa.create();this._baseUsedMemory=1816;this.init(b,a,d,e,c)}init(b,a,d,e,c){super.init(b,a,d,e,c);a=this.ellipsoid.radius;d=this.extentInRadians[0];e=this.extentInRadians[1];c=this.extentInRadians[2];const f=this.extentInRadians[3],x=ca.lerp(e,f,.5),l=ca.lerp(d,c,.5);this._edgeLen=(c-d)*Math.cos(0===b?0:Math.min(Math.abs(e),Math.abs(f)))*a;this._edgeLen2=this._edgeLen*this._edgeLen;this._curvatureHeight=a-Math.sqrt(a*a-this._edgeLen2/4);na.lonLatToSphericalPCPF(this.centerAtSeaLevel,
l,x,this.ellipsoid.radius);g.normalize(this.up,this.centerAtSeaLevel);this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const b=this._center;if(0===this.lij[0])g.set(b[N.CenterPosition.MIDDLE],0,0,0),g.set(b[N.CenterPosition.TOP],0,0,0),g.set(b[N.CenterPosition.BOTTOM],0,0,0),b[N.CenterPosition.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const f=b[N.CenterPosition.MIDDLE],x=this.convexHull;var a=0;for(let l=0;8>l;++l){var d=Math,
e=d.max;var c=3*l;c=da(f[0],f[1],f[2],x[c],x[c+1],x[c+2]);a=e.call(d,a,c)}b[N.CenterPosition.MIDDLE][3]=Math.sqrt(a)}}_calculateFrustumVisibilityStatus(b){if(!Z.intersectsSphere(b,this._boundingSphere))return U.TileFrustumVisibility.OUTSIDE;if(10>this.lij[0])return U.TileFrustumVisibility.INTERSECTS;const a=this.convexHull,d=this.surface.view.state.camera.near;let e=!0;for(let f=0;f<Z.NumPlanes;f++){var c=b[f];const x=c[0],l=c[1],C=c[2];c=c[3]-(f===Z.PlaneIndex.NEAR?d:0);let E=!1;for(let H=0;8>H;++H){const y=
3*H;if(0>x*a[y]+l*a[y+1]+C*a[y+2]+c){if(E=!0,!e)break}else e=!1}if(!E)return U.TileFrustumVisibility.OUTSIDE}return e?U.TileFrustumVisibility.INSIDE:U.TileFrustumVisibility.INTERSECTS}computeElevationBounds(){super.computeElevationBounds();this._updateBoundingVolumes()}createGeometry(){aa.createSphericalGlobePatch(this.renderData,this._getPatchType());this._updateBoundingVolumes();this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull();this._updateBoundingSphere();A.enableTerrainInternalChecks&&
this._checkBVs()}_updateBoundingSphere(){const b=this._boundingSphere;var a=this.elevationBounds,d=this.ellipsoid.radius,e=a[1];if(0===this.level)g.set(b,0,0,0),b[3]=d+e;else{e=this.extentInRadians;var c=.5*(e[0]+e[2]),f=e[3];J(ea,c,e[1],d);J(fa,c,f,d);g.add(b,ea,fa);g.scale(b,b,(d+.5*(a[0]+a[1]))/g.len(b));a=this.convexHull;d=0;for(e=0;8>e;++e){c=b[0]-a[3*e];f=b[1]-a[3*e+1];const x=b[2]-a[3*e+2];d=Math.max(d,Math.sqrt(c*c+f*f+x*x))}b[3]=d+2}}_updateConvexHull(){var b=this.extentInRadians,a=this.ellipsoid.radius;
if(0!==this.level){var d=this.elevationBounds,e=this._getPatchType(),c=this.surface.isWebMercator,f=c&&e===R.PatchType.HAS_NORTH_POLE,x=(e=c&&e===R.PatchType.HAS_SOUTH_POLE)||f;c=Math.PI/2;var l=b[0],C=b[2];e=e?-c:b[1];var E=f?c:b[3],H=.5*(l+C);b=d[0];var y=a+(x?Math.min(0,b-1):b);b=m.create();f=m.create();c=m.create();var I=m.create();J(b,l,e,y);J(f,l,E,y);J(c,C,E,y);J(I,C,e,y);l=(D,v)=>{for(let F=0;3>F;++F)this._convexHull[3*v+F]=D[F]};l(b,0);l(f,1);l(c,2);l(I,3);d=d[1];var W=a+(x?Math.max(0,d+
1):d),h=m.create();a=m.create();d=m.create();J(a,H,E,y);J(d,H,e,y);g.add(h,a,d);g.normalize(h,h);var w=m.create(),B=m.create();e=(D,v)=>{g.sub(B,D,v);g.normalize(B,B);v=-g.dot(D,w)/g.dot(B,w);A.internalAssert(0<=v);g.scale(B,B,v);g.add(D,D,B)};2**this.lij[0]>2*this.lij[1]?(a=m.create(),g.cross(a,ha,d),g.normalize(a,a),g.cross(w,d,a),g.normalize(w,w),A.internalAssert(A.almostEquals(g.dot(w,d)/g.len(d),0)),e(b,f),e(I,c),l(b,0),l(I,3)):2**this.lij[0]!==2*this.lij[1]&&(d=m.create(),g.cross(d,ha,a),g.normalize(d,
d),g.cross(w,d,a),g.normalize(w,w),e(f,b),e(c,I),l(f,1),l(c,2));a=(D,v)=>{const F=W/g.dot(v,h);for(let K=0;3>K;++K)this._convexHull[3*D+K]=v[K]*F};a(4,b);a(5,f);a(6,c);a(7,I)}}_getPatchType(){const b=this.lij[1],a=b===(1<<this.level)-1;return 0===b?a?R.PatchType.HAS_BOTH_POLES:R.PatchType.HAS_NORTH_POLE:a?R.PatchType.HAS_SOUTH_POLE:R.PatchType.REGULAR}intersectsRay(b,a,d,e){var c=this._boundingSphere;d=c[3]+d;var f=c[0]-b[0];e=c[1]-b[1];b=c[2]-b[2];c=(f*a[0]+e*a[1]+b*a[2])/(a[0]*a[0]+a[1]*a[1]+a[2]*
a[2]);f=a[0]*c-f;e=a[1]*c-e;a=a[2]*c-b;return f*f+e*e+a*a<d*d}getDefaultVerticesPerSide(){return this.level<ia.length?ia[this.level]+1:2}updateCornerElevations(){aa.updateCornerSpherical(this.renderData);this._updateBoundingVolumes()}updateEdgeElevations(){aa.updateEdgesAndCornersSpherical(this.renderData);this._updateBoundingVolumes()}_checkBVs(){if(A.enableTerrainInternalChecks&&!(2>=this.level)){var b=this._boundingSphere,a=b[3],d=m.create(),e=this.ellipsoid.radius,c=this.elevationBounds;c[1]-
c[0];var f=e+c[0],x=this._center[N.CenterPosition.MIDDLE][3],l=this.convexHull,C=(k,q)=>{for(let n=0;3>n;++n)k[n]=l[3*q+n]},E=m.create(),H=m.create(),y=m.create(),I=m.create(),W=m.create(),h=(k,q,n,G)=>{C(H,k);C(y,q);C(I,n);g.sub(H,H,y);g.sub(I,I,y);g.cross(E,H,I);g.normalize(E,E);var S=g.dot(E,y);C(W,G);const X=g.dot(E,W);S=Math.abs(X-S);A.internalAssert(A.almostEquals(S,0),`Non coplanar ${k},${q},${n},${G} diff = ${S}`)};h(0,1,2,3);h(4,5,6,7);h(0,1,4,5);h(1,2,5,6);h(2,3,6,7);h(3,0,7,4);var w=oa.newDoubleArray(24),
B=m.create(),D=m.create(),v=m.create(),F=m.create();h=(k,q,n,G)=>{C(B,q);C(D,n);C(v,G);g.sub(B,B,D);g.normalize(B,B);g.sub(v,v,D);g.normalize(v,v);g.cross(F,B,v);g.normalize(F,F);q=g.dot(F,D);k*=4;for(n=0;3>n;++n)w[k+n]=F[n];w[k+3]=q};h(0,0,1,2);h(1,1,0,4);h(2,1,5,2);h(3,3,2,6);h(4,4,0,3);h(5,4,6,5);var K=(k,q,n,G)=>{k*=4;return w[k]*q+w[k+1]*n+w[k+2]*G-w[k+3]},z=(k,q,n,G)=>-1<=K(k,q,n,G),L=2**this.lij[0]>2*this.lij[1];h=(k,q,n)=>Math.sqrt(da(k,q,n,b[0],b[1],b[2]))<a;var p=this.extentInRadians,t=
.5*(p[0]+p[2]),O=p[1],r=p[3];p=m.create();var u=m.create();J(p,t,r,f);J(u,t,O,f);f=L?"Upper":"Lower";L=!0;for(t=0;6>t;++t){for(O=0;8>O;++O)r=3*O,r=-1<=K(t,l[r],l[r+1],l[r+2]),L&&(L=r),A.internalAssert(r,`Tile[${this.lij}] Convex hull point ${O} outside of plane ${t}`);A.internalAssert(z(t,u[0],u[1],u[2]),`Tile[${this.lij}] (${f}) bottom mid outside of plane ${t}`);A.internalAssert(z(t,p[0],p[1],p[2]),`Tile[${this.lij}] (${f}) top mid outside of plane ${t}`)}A.internalAssert(L,"Not all convex hull points are inside  convex hull polyhedron");
A.internalAssert(h(u[0],u[1],u[2]),`Tile[${this.lij}] (${f}) bottom mid outside of bounding sphere`);A.internalAssert(h(p[0],p[1],p[2]),`Tile[${this.lij}] (${f}) top mid outside of bounding sphere`);for(z=0;8>z;++z)p=3*z,p=h(l[p],l[p+1],l[p+2]),A.internalAssert(p,`Tile[${this.lij}] Convex hull point ${z} outside of bounding sphere`);for(h=0;6>h;++h)for(z=0;8>z;++z)p=3*z,-1<=K(h,l[p],l[p+1],l[p+2])||console.error(`Tile[${this.lij}] Convex hull point ${z} outside of plane ${h}`);h=this.extentInRadians;
h=Math.round(Math.max(h[2]-h[0],h[3]-h[1])*e);if(t=this.renderData){var {geometry:ja,localOrigin:sa}=t;if(z=ja.vertexAttributes?.position){p=z.count;u=m.create();f=ja.numVerticesPerSide-2;L=f*f;t=t.geometryState.neighborData;O=t.edgeResolutions.reduce((k,q)=>k+q+1,0);for(let k=0;k<p;++k){const q=k<L,n=!q&&k<L+O;let G=!1;r=-1;if(n){var P=L;for(var Q=0;4>Q;++Q){var V=t.edgeResolutions[Q];if(k===P||k===P+V-1){G=!0;break}P+=V;if(k<P){r=Q;break}}}r=n?t.edgePeerNeighbors[r]:null;const S=n&&r&&0<qa.compareTilesByLij(this,
r);z.getVec(k,d);g.add(u,d,sa);r=g.len(u)-e;P=0;Q=!1;V=c[0]-r;const X=r-c[1],ka=1<V,la=1<X;var M=ka||la;const ma=()=>{const Y=n&&!G;return`Tile[${this.lij}].vertex[${k}]:${q?"internal":Y?"edge":G?"corner":"pole"}`+(ka?"(below)":la?"(above)":"")+(S?"(Neighbor)":"")};var T=g.dist(u,b);T>=a+0&&(T-=a,M||(console.error(`${ma()} is out of the bounding sphere by ${T.toFixed(0)} / ${a.toFixed(0)}`+"[tol\x3d0]"+` h=${r.toFixed(0)} / [${c[0].toFixed(0)}..${c[1].toFixed(0)}] (${(T/a).toFixed(0)})`),Q=!0));for(M=
0;6>M;++M)if(!(-1<=K(M,u[0],u[1],u[2]))){T=K(M,u[0],u[1],u[2]);const Y=k%f,ta=(k-Y)/f;0===M&&V||5===M&&X||(console.error(`${ma()} (${Y},${ta})|${f}] is out of the bounding trapezoid plane ${M}`+` h=${Math.round(r)} / [${Math.round(c[0])}..${Math.round(c[1])}] dist=${Math.round(T)}`+` radii = ${Math.round(a)}/${Math.round(x)}} : maxL = ${h}`),++P)}if(Q||0<P)break}}}}}get convexHull(){return this._convexHull}}const ia=[128,64,64,32,16,8,8,4],J=(b,a,d,e)=>{const c=Math.sin(a),f=Math.cos(d);d=Math.sin(d);
b[0]=e*f*Math.cos(a);b[1]=e*f*c;b[2]=e*d},ha=[0,0,1],ea=m.create(),fa=m.create();ba.SphericalPatch=ra;Object.defineProperty(ba,Symbol.toStringTag,{value:"Module"})});