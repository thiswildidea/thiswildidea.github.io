// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ../../../../core/promiseUtils ../../../../core/urlUtils ../../../../core/workers/workers ./GlyphMosaic ./GlyphSource ./SpriteMosaic ../../tiling/TileKey".split(" "),function(q,x,n,r,y,t,u,v,w){function z(a){return()=>a.abort()}class A{constructor(a,b,c){this._layer=a;this._styleRepository=b;this.devicePixelRatio=c;this._inputSignalEventListener=this._startOptionsInputSignal=this._spriteSourceAbortController=this._connection=this._glyphMosaic=this._spriteMosaic=
null}destroy(){this._connection?.close();this._layer=this._styleRepository=this._connection=null;this._spriteMosaic?.destroy();this._glyphMosaic=this._spriteMosaic=null;this._spriteSourceAbortController=x.abortMaybe(this._spriteSourceAbortController);this._spriteSourcePromise=null;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener);this._inputSignalEventListener=this._startOptionsInputSignal=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>
this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(a){this._requestSprite(a);var b=this._layer.currentStyleInfo.glyphsUrl;b=new u(b?r.addQueryParameters(b,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new t(1024,1024,b);this._broadcastPromise=y.open("WorkerTileHandler",{client:this,schedule:a.schedule,signal:a.signal}).then(c=>{this._layer&&(this._connection?.close(),this._connection=c,this._layer&&!this._connection.closed&&(c=c.broadcast("setStyle",
this._layer.currentStyleInfo.style,a),Promise.all(c).catch(d=>n.throwIfNotAbortError(d))))})}_requestSprite(a){this._spriteSourceAbortController?.abort();const b=new AbortController;this._spriteSourceAbortController=b;const c=a?.signal;this._inputSignalEventListener&&this._startOptionsInputSignal?.removeEventListener("abort",this._inputSignalEventListener);this._startOptionsInputSignal=null;c&&(this._inputSignalEventListener=z(b),c.addEventListener("abort",this._inputSignalEventListener,{once:!0}));
const {signal:d}=b;this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,{...a,signal:d});this._spriteSourcePromise.then(e=>{n.throwIfAbortError(d);this._spriteMosaic=new v(1024,1024,250);this._spriteMosaic.setSpriteSource(e)})}async updateStyle(a){await this._broadcastPromise;return this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",a))}setSpriteSource(a){const b=new v(1024,1024,250);b.setSpriteSource(a);this._spriteMosaic=b;this._spriteSourcePromise=
Promise.resolve(a);this._spriteSourceAbortController=null;return b}async setStyle(a,b){await this._broadcastPromise;this._styleRepository=a;this._requestSprite();a=new u(this._layer.currentStyleInfo.glyphsUrl?r.addQueryParameters(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new t(1024,1024,a);return this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",b))}fetchTileData(a,b){return this._getRefKeys(a,
b).then(c=>{const d=this._layer.sourceNameToSource,e=[];for(const f in d)e.push(f);return this._getSourcesData(e,c,b)})}parseTileData(a,b){const c=a&&a.data;if(!c)return Promise.resolve(null);const {sourceName2DataAndRefKey:d,transferList:e}=c;return 0===Object.keys(d).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:a.key.id,sourceName2DataAndRefKey:d,styleLayerUIDs:a.styleLayerUIDs},{...b,transferList:e}))}async getSprites(a){await this._spriteSourcePromise;
return this._spriteMosaic.getSpriteItems(a)}getGlyphs(a){return this._glyphMosaic.getGlyphItems(a.font,a.codePoints)}async _getTilePayload(a,b,c){a=w.pool.acquire(a.id);const d=this._layer.sourceNameToSource[b],{level:e,row:f,col:k}=a;w.pool.release(a);try{return{protobuff:await d.requestTile(e,f,k,c),sourceName:b}}catch(h){if(n.isAbortError(h))throw h;return{protobuff:null,sourceName:b}}}_getRefKeys(a,b){const c=this._layer.sourceNameToSource,d=[];for(const e in c){const f=c[e].getRefKey(a,b);d.push(f)}return Promise.allSettled(d)}_getSourcesData(a,
b,c){const d=[];for(let f=0;f<b.length;f++){var e=b[f];e="fulfilled"===e.status?e.value:null;null==e||null==a[f]?d.push(null):(e=this._getTilePayload(e,a[f],c),d.push(e))}return Promise.allSettled(d).then(f=>{const k={},h=[];for(let l=0;l<f.length;l++){var g=f[l];g="fulfilled"===g.status?g.value:null;const p=g?.protobuff;if(g&&p?.byteLength){var m=b[l];if(m="fulfilled"===m.status?m.value:null)k[g.sourceName]={refKey:m.id,protobuff:p},h.push(p)}}return{sourceName2DataAndRefKey:k,transferList:h}})}}
q.TileHandler=A;Object.defineProperty(q,Symbol.toStringTag,{value:"Module"})});