// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ../../../../core/typedArrayUtil ./enums ./decluttering/util ../../../webgl/BufferObject ../../../webgl/enums ../../../webgl/VertexArrayObject".split(" "),function(m,n,v,t,w,h,k,p){class r{constructor(a,b){this.layerUIDs=[];this.isDestroyed=!1;this._data=a;let c=1;a=new Uint32Array(a);this.layerUIDs=[];const d=a[c++];for(let e=0;e<d;e++)this.layerUIDs[e]=a[c++];this.bufferDataOffset=c;b&&(this.layer=b.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return null==
this._data}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(a){null!=this._data&&(this.doPrepareForRendering(a,this._data,this.bufferDataOffset),this._data=null)}}class x extends r{constructor(a,b){super(a,b);this.type=t.BucketType.LINE;this.lineIndexCount=this.lineIndexStart=0;a=new Uint32Array(a);b=this.bufferDataOffset;this.lineIndexStart=a[b++];this.lineIndexCount=a[b++];
const c=a[b++];if(0<c){this.patternMap=new Map;for(let d=0;d<c;d++){const e=a[b++],g=a[b++],f=a[b++];this.patternMap.set(e,[g,f])}}this.bufferDataOffset=b}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return 0<this.lineIndexCount}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=n.disposeMaybe(this.vao)}doPrepareForRendering(a,b,c){var d=new Uint32Array(b);b=new Int32Array(d.buffer);var e=d[c++];b=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,
new Int32Array(b.buffer,4*c,e));c+=e;e=d[c++];d=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,new Uint32Array(d.buffer,4*c,e));c+=e;c=this.layer.lineMaterial;this.vao=new p.VertexArrayObject(a,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:b},d)}}class y extends r{constructor(a,b){super(a,b);this.type=t.BucketType.FILL;this.outlineIndexCount=this.outlineIndexStart=this.fillIndexCount=this.fillIndexStart=0;a=new Uint32Array(a);b=this.bufferDataOffset;this.fillIndexStart=a[b++];this.fillIndexCount=
a[b++];this.outlineIndexStart=a[b++];this.outlineIndexCount=a[b++];const c=a[b++];if(0<c){this.patternMap=new Map;for(let d=0;d<c;d++){const e=a[b++],g=a[b++],f=a[b++];this.patternMap.set(e,[g,f])}}this.bufferDataOffset=b}get memoryUsed(){return(this.data?.byteLength??0)+(this.fillVAO?.usedMemory??0)+(this.outlineVAO?.usedMemory??0)}hasData(){return 0<this.fillIndexCount||0<this.outlineIndexCount}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=n.disposeMaybe(this.fillVAO);
this.outlineVAO=n.disposeMaybe(this.outlineVAO)}doPrepareForRendering(a,b,c){var d=new Uint32Array(b),e=new Int32Array(d.buffer),g=d[c++];b=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,new Int32Array(e.buffer,4*c,g));c+=g;var f=d[c++];g=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,new Uint32Array(d.buffer,4*c,f));c+=f;f=d[c++];e=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,new Int32Array(e.buffer,4*c,f));c+=f;f=d[c++];d=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,new Uint32Array(d.buffer,
4*c,f));c+=f;f=this.layer;c=f.fillMaterial;f=f.outlineMaterial;this.fillVAO=new p.VertexArrayObject(a,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:b},g);this.outlineVAO=new p.VertexArrayObject(a,f.getAttributeLocations(),f.getLayoutInfo(),{geometry:e},d)}}class z extends r{constructor(a,b,c){super(a,b);this.type=t.BucketType.SYMBOL;this.iconPerPageElementsMap=new Map;this.glyphPerPageElementsMap=new Map;this.symbolInstances=[];this.opacityChanged=this.isIconSDF=!1;this.lastOpacityUpdate=
0;this.symbols=[];b=new Uint32Array(a);const d=new Int32Array(a);a=new Float32Array(a);let e=this.bufferDataOffset;this.isIconSDF=!!b[e++];var g=b[e++];for(var f=0;f<g;f++){var l=b[e++],q=b[e++],u=b[e++];this.iconPerPageElementsMap.set(l,[q,u])}g=b[e++];for(f=0;f<g;f++)l=b[e++],q=b[e++],u=b[e++],this.glyphPerPageElementsMap.set(l,[q,u]);g=b[e++];f=b[e++];this.iconOpacity=new Int32Array(g);this.textOpacity=new Int32Array(f);this.bufferDataOffset=e=w.deserializeSymbols(b,d,a,e,this.symbols,c)}get memoryUsed(){return(this.data?.byteLength??
0)+(this.iconVAO?.usedMemory??0)+(this.textVAO?.usedMemory??0)+v.estimateSize(this.iconOpacity)+v.estimateSize(this.textOpacity)}hasData(){return 0<this.iconPerPageElementsMap.size||0<this.glyphPerPageElementsMap.size}triangleCount(){let a=0;for(const [,b]of this.iconPerPageElementsMap)a+=b[1];for(const [,b]of this.glyphPerPageElementsMap)a+=b[1];return a/3}doDestroy(){this.iconVAO=n.disposeMaybe(this.iconVAO);this.textVAO=n.disposeMaybe(this.textVAO)}updateOpacityInfo(){if(this.opacityChanged){this.opacityChanged=
!1;var a=this.iconOpacity,b=this.iconVAO.vertexBuffers.opacity;0<a.length&&a.byteLength===b.byteLength&&b.setSubData(a,0,0,a.length);a=this.textOpacity;b=this.textVAO.vertexBuffers.opacity;0<a.length&&a.byteLength===b.byteLength&&b.setSubData(a,0,0,a.length)}}doPrepareForRendering(a,b,c){var d=new Uint32Array(b),e=new Int32Array(d.buffer),g=d[c++];b=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,new Int32Array(e.buffer,4*c,g));c+=g;var f=d[c++];g=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,
new Uint32Array(d.buffer,4*c,f));c+=f;f=d[c++];e=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,new Int32Array(e.buffer,4*c,f));c+=f;f=d[c++];d=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,new Uint32Array(d.buffer,4*c,f));c+=f;c=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,this.iconOpacity.buffer);f=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,this.textOpacity.buffer);var l=this.layer;const q=l.iconMaterial;l=l.textMaterial;this.iconVAO=new p.VertexArrayObject(a,q.getAttributeLocations(),
q.getLayoutInfo(),{geometry:b,opacity:c},g);this.textVAO=new p.VertexArrayObject(a,l.getAttributeLocations(),l.getLayoutInfo(),{geometry:e,opacity:f},d)}}class A extends r{constructor(a,b){super(a,b);this.type=t.BucketType.CIRCLE;this.circleIndexCount=this.circleIndexStart=0;a=new Uint32Array(a);b=this.bufferDataOffset;this.circleIndexStart=a[b++];this.circleIndexCount=a[b++];this.bufferDataOffset=b}get memoryUsed(){return(this.data?.byteLength??0)+(this.vao?.usedMemory??0)}hasData(){return 0<this.circleIndexCount}triangleCount(){return this.circleIndexCount/
3}doDestroy(){this.vao=n.disposeMaybe(this.vao)}doPrepareForRendering(a,b,c){var d=new Uint32Array(b);b=new Int32Array(d.buffer);var e=d[c++];b=h.BufferObject.createVertex(a,k.Usage.STATIC_DRAW,new Int32Array(b.buffer,4*c,e));c+=e;e=d[c++];d=h.BufferObject.createIndex(a,k.Usage.STATIC_DRAW,new Uint32Array(d.buffer,4*c,e));c+=e;c=this.layer.circleMaterial;this.vao=new p.VertexArrayObject(a,c.getAttributeLocations(),c.getLayoutInfo(),{geometry:b},d)}}m.CircleRenderBucket=A;m.FillRenderBucket=y;m.LineRenderBucket=
x;m.RenderBucketBase=r;m.SymbolRenderBucket=z;Object.defineProperty(m,Symbol.toStringTag,{value:"Module"})});