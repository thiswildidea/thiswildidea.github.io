// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/arrayUtils ./enums ./MemoryRequirements ./TileBufferData ./TileDisplayData ./Utils ./WGLDisplayRecord ./cpuMapped/DisplayRecordReader ./mesh/VertexBuffer ./mesh/VertexVector ./util/Writer".split(" "),function(w,x,B,y,v,z,t,A,C,D,E,F){const u=new y,n=new y;class m{constructor(){this.tileBufferData=this.tileDisplayData=null}reshuffle(){u.reset();if(this.tileDisplayData){var b=[[],[],[],[],[]],d=this.tileDisplayData.displayObjects;for(var a of d)for(var e of a.displayRecords)b[e.geometryType].push(e);
for(var g of b)for(var f of g)f&&u.needMore(f.geometryType,f.meshData?f.meshData.vertexCount:f.vertexCount,f.meshData?f.meshData.indexData.length:f.indexCount);d=b.length;a=new v;for(e=0;e<d;++e)if(a.geometries[e].indexBuffer=new Uint32Array(Math.round(x.ReallocGrowthFactor*u.indicesFor(e))),f=[],g=this.tileBufferData?.geometries[e].vertexBuffer){for(var c in g)f.push(g[c].stride);f=m._computeVertexAlignment(f);var h=Math.round(x.ReallocGrowthFactor*u.verticesFor(e));f=m._align(h,f);for(var l in g)h=
g[l].stride,a.geometries[e].vertexBuffer[l]={stride:h,data:t.allocateTypedArrayBuffer(f,h)}}n.reset();this.tileDisplayData.displayList?.clear();for(c=0;c<d;++c){l=b[c];for(const k of l){if(k.meshData)k.writeMeshDataToBuffers(n.verticesFor(c),a.geometries[c].vertexBuffer,n.indicesFor(c),a.geometries[c].indexBuffer),k.meshData=null;else if(e=this.tileBufferData?.geometries[c]){l=e.vertexBuffer;e=e.indexBuffer;g=a.geometries[c].vertexBuffer;f=a.geometries[c].indexBuffer;h=n.verticesFor(c);const p=n.indicesFor(c);
t.copyMeshData(h,p,g,f,k,l,e);k.vertexFrom=h;k.indexFrom=p}n.needMore(c,k.vertexCount,k.indexCount)}}var {displayList:q,displayObjects:r}=this.tileDisplayData;if(q)for(const k of r)q.addToList(k.displayRecords);this.tileBufferData=a}}getStrides(){const b=[],d=this.tileBufferData?.geometries;if(!d)return b;for(let a=0;a<d.length;++a){const e=d[a];b[a]={};for(const g in e.vertexBuffer)b[a][g]=e.vertexBuffer[g].stride}return b}clone(){const b=new m;b.tileBufferData=this.tileBufferData?.clone()??null;
b.tileDisplayData=this.tileDisplayData?.clone()??null;return b}_guessSize(){const b=this.tileDisplayData?.displayObjects??[],d=Math.min(b.length,4);let a=0;for(let e=0;e<d;e++)a=Math.max(a,b[e].displayRecords.length);return 2*(12*b.length+b.length*a*40)}serialize(){const b=this.tileBufferData.serialize(),d=this.tileBufferData.getBuffers(),a=this.tileDisplayData.serialize(new F(Int32Array,this._guessSize())).buffer();d.push(a);return{result:{displayData:a,bufferData:b},transferList:d}}static fromVertexData(b,
d){const a={},e=new Map;for(const g of d)e.set(g.id,g);t.forEachGeometryType(g=>{const f=b.data[g];if(null!=f){const h=C.DisplayRecordReader.from(f.records).getCursor();for(;h.next();){var c=h.id;const l=h.materialKey,q=h.indexFrom,r=h.indexCount,k=h.vertexFrom,p=h.vertexCount,G=e.get(c);c=new A(c,g,l);c.indexFrom=q;c.indexCount=r;c.vertexFrom=k;c.vertexCount=p;G.displayRecords.push(c)}a[g]=D.VertexBuffers.fromVertexData(f,g)}else a[g]=(new E.VertexVectors(g,0,B.WGLSymbologyType.DEFAULT)).intoBuffers()});
return m.fromMeshData({displayObjects:d,vertexBuffersMap:a})}static fromMeshData(b){const d=new m,a=new z,e=new v;a.displayObjects=b.displayObjects;for(const g in b.vertexBuffersMap){const f=g,c=b.vertexBuffersMap[f];e.geometries[f].indexBuffer=c.indexBuffer;e.geometries[f].vertexBuffer=c.namedBuffers}d.tileDisplayData=a;d.tileBufferData=e;return d}static bind(b,d){const a=new m;a.tileDisplayData=b;a.tileBufferData=d;return a}static create(b,d){const a=new m;a.tileDisplayData=new z;a.tileDisplayData.displayObjects=
b;const e=[0,0,0,0,0],g=[0,0,0,0,0],f=[[],[],[],[],[]];for(var c of b)for(var h of c.displayRecords)f[h.geometryType].push(h),e[h.geometryType]+=h.meshData.vertexCount,g[h.geometryType]+=h.meshData.indexData.length;b=new v;d=[d.fill||{},d.line||{},d.icon||{},d.text||{},d.label||{}];for(c=0;5>c;c++){h=new Uint32Array(g[c]);var l=d[c],q=e[c];const r={};for(const k in l){const p={data:t.allocateTypedArrayBuffer(q,l[k]),stride:l[k]};r[k]=p}l=r;A.writeAllMeshDataToBuffers(f[c],l,h);b.geometries[c]={indexBuffer:h,
vertexBuffer:l}}a.tileBufferData=b;return a}static _align(b,d){const a=b%d;return 0===a?b:b+(d-a)}static _computeVertexAlignment(b){let d=!1,a=!1;for(const e of b)2===e%4?d=!0:0!==e%4&&(a=!0);return a?4:d?2:1}}w.TileData=m;Object.defineProperty(w,Symbol.toStringTag,{value:"Module"})});