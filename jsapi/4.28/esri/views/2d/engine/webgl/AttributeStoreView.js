// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/Error ../../../../core/has ../../../../core/Logger ../../../../core/promiseUtils ./definitions ./DisplayId ./Utils ./util/debug ../../../webgl/enums ../../../webgl/FramebufferObject ../../../webgl/Texture ../../../webgl/TextureDescriptor".split(" "),function(x,y,q,E,F,e,z,k,A,l,G,B,C){const r=E.getLogger("esri.views.2d.engine.webgl.AttributeStoreView"),t=A.createDebugLogger(A.debugAttrUpdates,r);class D{constructor(a,b,c){this._lastTexture=this._texture=null;this._fbos=
{};this.texelSize=4;const {buffer:d,pixelType:f,textureOnly:g}=a;a=k.getPixelArrayCtor(f);this.shared=c;this.pixelType=f;this.size=b;this.textureOnly=g;g||(this.data=new a(d));this._resetRange()}destroy(){this._texture?.dispose();for(const a in this._fbos){const b=this._fbos[a];b&&("0"===a&&b.detachColorTexture(),b.dispose());this._fbos[a]=null}this._texture=null}get _textureDesc(){const a=new C.TextureDescriptor;a.wrapMode=l.TextureWrapMode.CLAMP_TO_EDGE;a.samplingMode=l.TextureSamplingMode.NEAREST;
a.dataType=this.pixelType;a.width=this.size;a.height=this.size;return a}setData(a,b,c){a=z.getDisplayIdTexel(a);const d=this.data;b=a*this.texelSize+b;!d||b>=d.length||(d[b]=c,this.dirtyStart=Math.min(this.dirtyStart,a),this.dirtyEnd=Math.max(this.dirtyEnd,a))}getData(a,b){if(null==this.data)return null;a=z.getDisplayIdTexel(a)*this.texelSize+b;return!this.data||a>=this.data.length?null:this.data[a]}getTexture(a){return this._texture??this._initTexture(a)}getFBO(a,b=0){if(!this._fbos[b]){const c=
0===b?this.getTexture(a):this._textureDesc;this._fbos[b]=new G.FramebufferObject(a,c)}return this._fbos[b]}get locked(){return this.pixelType===l.PixelType.UNSIGNED_BYTE&&this.shared&&!this.textureOnly&&q("esri-atomics")&&this.data?1===Atomics.load(this.data,0):!1}get hasDirty(){return this.dirtyEnd>=this.dirtyStart}updateTexture(a,b){if(!this.locked){try{const c=this.dirtyStart,d=this.dirtyEnd;if(!this.hasDirty)return;this._resetRange();const f=this.data.buffer,g=this.getTexture(a),h=(c-c%this.size)/
this.size,n=(d-d%this.size)/this.size,m=h*this.size*4,u=4*(this.size+n*this.size)-m,p=k.getPixelArrayCtor(this.pixelType),v=new p(f,m*p.BYTES_PER_ELEMENT,u),w=this.size;a=n-h+1;if(a>this.size){r.error(new y("mapview-webgl","Out-of-bounds index when updating AttributeData"));return}g.updateData(0,0,h,w,a,v)}catch(c){}b()}}update(a){const {data:b,start:c,end:d}=a;if(null!=b&&null!=this.data){const f=this.data,g=c*this.texelSize;for(let h=0;h<b.length;h++)a.layout&1<<h%this.texelSize&&(f[g+h]=b[h])}this.dirtyStart=
Math.min(this.dirtyStart,c);this.dirtyEnd=Math.max(this.dirtyEnd,d)}resize(a,b){const c=this.size;this.size=b;this.textureOnly?c!==this.size&&(this._lastTexture=this._texture,this._texture=null):(b=k.getPixelArrayCtor(this.pixelType),this.destroy(),this.data=new b(a.buffer))}_resetRange(){this.dirtyStart=2147483647;this.dirtyEnd=0}_initTexture(a){const b=new B.Texture(a,this._textureDesc,this.data??void 0);if(null!=this._lastTexture&&this._fbos[0]){const f=this._lastTexture.descriptor.width,g=this._lastTexture.descriptor.height,
h=this._lastTexture.descriptor.dataType,n=this._lastTexture.descriptor.pixelFormat,m=this.getFBO(a);var c=k.getPixelBytes(h),d=k.getPixelArrayCtor(h);c=new ArrayBuffer(f*g*c*this.texelSize);d=new d(c);c=a.getBoundFramebufferObject();const {x:u,y:p,width:v,height:w}=a.getViewport();a.bindFramebuffer(m);m.readPixels(0,0,f,g,n,h,d);b.updateData(0,0,0,2*f,g/2,d);a.setViewport(u,p,v,w);a.bindFramebuffer(c)}this.destroy();return this._texture=b}}class H{constructor(a){this._onUpdate=a;this._locked=this._forceNextUpload=
this._initialized=!1}initialize(a){const {blocks:b,shared:c,size:d}=a;this.shared=c;this.size=d;t("Initializing AttributeStoreView",a);if(null==this._data)this._data=b.map(f=>null!=f?new D(f,d,c):null);else for(a=0;a<this._data.length;a++){const f=this._data[a],g=b[a];null!=g&&(null==f?this._data[a]=new D(g,d,c):f.resize(g,d))}this._initialized=!0}destroy(){for(const a of this._data??[])a?.destroy();this._defaultTexture?.dispose()}isEmpty(){return null==this._data}isUpdating(){const a=null!=this._pendingAttributeUpdate;
q("esri-2d-log-updating")&&console.log(`Updating AttributeStoreView ${a}\n  -> hasPendingUpdate ${a}`);return a}getBlock(a){return null==this._data?null:this._data[a]}setLabelMinZoom(a,b){this.setData(a,0,1,b)}getLabelMinZoom(a){return this.getData(a,0,1,255)}getFilterFlags(a){return this.getData(a,0,0,0)}getVVSize(a){return this.getData(a,e.attributeDataVv,0,0)}getData(a,b,c,d){if(!this._data)return 0;b=this._data[b];if(null==b)return 0;a=b.getData(a,c);return null!=a?a:d}setData(a,b,c,d){this._data[b].setData(a,
c,d)}lockTextureUpload(){this._locked=!0}unlockTextureUpload(){this._locked=!1}forceTextureUpload(){this._forceNextUpload=!0}async requestUpdate(a){if(this._pendingAttributeUpdate)r.error(new y("mapview-webgl","Tried to update attribute data with a pending update"));else{var b=F.createResolver();t("AttributeStoreView Update Requested",a);this._pendingAttributeUpdate={data:a,resolver:b};this._onUpdate();return b.promise}}update(){if(this._initialized&&null!=this._pendingAttributeUpdate){q("esri-2d-update-debug")&&
console.debug("AttributeStoreView::update");const {data:a,resolver:b}=this._pendingAttributeUpdate,c=this._data;for(let d=0;d<a.blocks.length;d++){const f=a.blocks[d],g=c[d];null!=g&&null!=f&&(t(`Updating block ${d}`,f),g.update(f))}this._pendingAttributeUpdate=null;b();this._onUpdate()}}bindTextures(a,b=!0){const c=this._getDefaultTexture(a);if(this._initialized){var d=this._data;if(!this._locked||this._forceNextUpload){for(const f of d)f?.updateTexture(a,()=>this._onUpdate());this._forceNextUpload=
!1}a.bindTexture(d[e.attributeDataFilterFlags]?.getTexture(a)??c,e.textureBindingAttributeData0);b&&(a.bindTexture(d[e.attributeDataGpgpu]?.getTexture(a)??c,e.textureBindingGpgpu),a.bindTexture(d[e.attributeDataAnimation]?.getTexture(a)??c,e.textureBindingAttributeData1),a.bindTexture(d[e.attributeDataVv]?.getTexture(a)??c,e.textureBindingAttributeData2),a.bindTexture(d[e.attributeDataDd1]?.getTexture(a)??c,e.textureBindingAttributeData3),a.bindTexture(d[e.textureBindingAttributeData4]?.getTexture(a)??
c,e.textureBindingAttributeData4),a.bindTexture(d[e.textureBindingAttributeData5]?.getTexture(a)??c,e.textureBindingAttributeData5))}else a.bindTexture(c,e.textureBindingAttributeData0),b&&(a.bindTexture(c,e.textureBindingAttributeData1),a.bindTexture(c,e.textureBindingAttributeData2),a.bindTexture(c,e.textureBindingAttributeData3),a.bindTexture(c,e.textureBindingAttributeData4),a.bindTexture(c,e.textureBindingAttributeData5),a.bindTexture(c,e.textureBindingGpgpu))}_getDefaultTexture(a){if(null==
this._defaultTexture){const b=new C.TextureDescriptor;b.wrapMode=l.TextureWrapMode.CLAMP_TO_EDGE;b.samplingMode=l.TextureSamplingMode.NEAREST;b.width=1;b.height=1;this._defaultTexture=new B.Texture(a,b,new Uint8Array(4))}return this._defaultTexture}}x.AttributeStoreView=H;Object.defineProperty(x,Symbol.toStringTag,{value:"Module"})});