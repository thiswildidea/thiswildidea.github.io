// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("../../../chunks/tslib.es6 ../../../core/arrayUtils ../../../core/Error ../../../core/maybe ../../../core/promiseUtils ../../../core/accessorSupport/decorators/property ../../../core/accessorSupport/ensureType ../../../core/has ../../../core/accessorSupport/decorators/subclass ../../../layers/support/arcgisLayerUrl ../../../layers/support/fieldUtils ../../../rest/generateRenderer ../../../rest/support/GenerateRendererParameters ../../../rest/support/StatisticDefinition ../../../rest/support/UniqueValueDefinition ../../statistics/support/predominanceUtils ../../statistics/support/utils ../../statistics/support/WorkerClient ../utils ./InMemoryLayerAdapter ./support/utils ../../../statistics/utils".split(" "),
function(F,G,v,I,x,J,C,S,K,L,A,M,D,N,O,H,q,P,y,Q,m,w){C=class extends Q{constructor(){super(...arguments);this.adapterName="feature-layer-adapter"}_isStatsSupportedOnService(){const a=this.layer;if(!a.capabilities?.query?.supportsStatistics||"multipatch"===this.geometryType&&!L.isHostedAgolService(a.url)&&10.5>a.version)throw new v(`${this.adapterName}:not-supported`,"Layer does not support statistics query");return Promise.resolve()}_fetchFeaturesFromService(a,c){return this.layer.queryFeatures(a,
{signal:c}).then(b=>b.features)}_fetchFeaturesJSONFromService(a,c){return this._fetchFeaturesFromService(a,c).then(m.ensureFeaturesJSON)}_summaryStatsFromGenRend(a){const c=a.normalizationType,b=a.normalizationField;return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:c,normalizationField:"field"===c?b:void 0,minValue:a.minValue,maxValue:a.maxValue,filter:a.filter,signal:a.signal}).then(d=>{let h,k;d.classBreakInfos?.some(f=>
{f.hasAvg&&(h=f);return!!h});if(h){var g=h.maxValue-h.minValue;k=h.minValue+g/2;g*=4}return w.processSummaryStatisticsResult({min:d.minValue,max:d.maxValue,avg:k,stddev:g})})}async _summaryStatsFromServiceQuery(a,c){await this._isStatsSupportedOnService();"percent-of-total"===a.normalizationType&&(a.normalizationTotal=await this._getNormalizationTotal(a.field,a.normalizationType,a.filter));var b=y.isAnyDateField(c)||A.isTimeOnlyField(c);c=m.getSummaryStatsQuery(this,a,c);a=await this.layer.queryFeatures(c,
{signal:a.signal});b=m.getSummaryStatisticsFromFeatureSet(a,b);return w.processSummaryStatisticsResult(b)}_uvFromGenRenderer(a,c){const b=a.field??void 0,d=new O;d.attributeField=b;const h=new D;h.classificationDefinition=d;return this.generateRenderer(h,a.signal).then(k=>{const g={},f=this.getField(b);k.uniqueValues.forEach(e=>{let l=e.value;if(null==l||""===l||"string"===typeof l&&(""===l.trim()||"\x3cnull\x3e"===l.toLowerCase()))l=null;null==g[l]?g[l]={count:e.count,data:A.isNumericField(f)&&l?
Number(l):l}:g[l].count+=e.count});return{count:g}}).then(k=>w.createUVResult(k,[c],a.returnAllCodedValues))}async _uvFromServiceQuery(a,c){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(m.getUVQuery(this,a),{signal:a.signal})).then(b=>m.getUniqueValuesFromFeatureSet(b,{layer:this,field:a.field,field2:a.field2,field3:a.field3,fieldDelimiter:y.fieldDelimiter,view:a.view,signal:a.signal})).then(b=>w.createUVResult(b,c,a.returnAllCodedValues,y.fieldDelimiter))}_calcBinsSQL(a,
c,b){const d=[],h=c.length;c.forEach((k,g)=>{const [f,e]=k;k=null;k=0!==g||b?g!==h-1||b?q.mergeWhereClauses(`${a} >= ${f}`,`${a} ${g===h-1?" \x3c\x3d ":" \x3c "} ${e}`):`${a} >= ${f}`:`${a} < ${e}`;d.push("WHEN ("+k+") THEN "+(g+1))});return["CASE",d.join(" "),"ELSE 0 END"].join(" ")}_getNormalizationTotal(a,c,b,d){return a&&"percent-of-total"===c?this.summaryStatistics({field:a,filter:b,signal:d}).then(h=>h.sum):Promise.resolve(null)}_getQueryParamsForExpr(a,c){const b=a.signal;if(!a.valueExpression&&
!a.sqlExpression){const {field:d,normalizationType:h,normalizationField:k}=a,g=d?this.getField(d):null,f=y.isAnyDateField(g)||A.isTimeOnlyField(g);c={field:d,normalizationType:h,normalizationField:k,normalizationTotal:c,layer:this};return{sqlExpression:f?m.getSQLExpressionForDateOrTimeField(this,g):m.getFieldExpr(c),sqlWhere:f?null:a.sqlWhere||q.getSQLFilterForNormalization({field:d,normalizationType:h,normalizationField:k}),filter:a.filter,signal:b}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,
sqlWhere:a.sqlWhere,filter:a.filter,signal:b}}_getDataRange(a,c,b){return null!=c&&null!=b?Promise.resolve({min:c,max:b}):this.summaryStatistics(a).then(d=>({min:d.min,max:d.max}))}_histogramForExpr(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.filter,a.signal).then(c=>{const b=this._getQueryParamsForExpr(a,c);return this._getDataRange(b,a.minValue,a.maxValue).then(d=>{const h=d.min,k=d.max;if(null==h||null==k)return{bins:[],minValue:h,maxValue:k,normalizationTotal:c};const g=
a.numBins||m.defaultNumBins;d=w.getEqualIntervalBins(h,k,g);d=this._calcBinsSQL(b.sqlExpression,d,null!=a.minValue&&null!=a.maxValue);const f=new N({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),e=this.layer.createQuery();e.where=q.mergeWhereClauses(e.where,b.sqlWhere);e.sqlFormat="standard";e.outStatistics=[f];e.groupByFieldsForStatistics=[d];e.orderByFields=[d];m.updateQueryWithFeatureFilter(e,a.filter);return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(e,
{signal:b.signal})).then(l=>m.getHistogramFromFeatureSet(l,h,k,g,c))})})}_binParamsFromGenRend(a,c){const {field:b,normalizationType:d,normalizationField:h,signal:k}=a,g=q.getSQLFilterForNormalization({field:b,normalizationType:d,normalizationField:h});a=new D({classificationDefinition:w.createClassBreaksDefinition({field:b,normalizationType:d,normalizationField:h,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numBins||m.defaultNumBins}),
where:q.mergeWhereClauses(g,c)});return this.generateRenderer(a,k).then(f=>{const {normalizationTotal:e,classBreaks:l}=f;return m.generateBinParams({field:b,normalizationType:d,normalizationField:h,normalizationTotal:e,classBreaks:l,where:g,layer:this})})}_classBreaksFromGenRend(a){const {field:c,normalizationType:b,normalizationField:d,normalizationTotal:h,signal:k}=a,g=q.getSQLFilterForNormalization({field:c,normalizationType:b,normalizationField:d});var f=m.getFieldExpr({field:c,normalizationType:b,
normalizationField:d,normalizationTotal:h,layer:this});f=q.getRangeExpr(f,a.minValue,a.maxValue);const e=w.createClassBreaksDefinition({field:c,normalizationType:b,normalizationField:d,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numClasses||5}),l=new D;l.classificationDefinition=e;l.where=q.mergeWhereClauses(g,f);return this.generateRenderer(l,k).then(n=>w.resolveCBResult(n,a.classificationMethod))}async summaryStatistics(a){const {field:c,
normalizationType:b,sqlExpression:d,view:h,features:k,useFeaturesInView:g}=a,f=c?this.getField(c):null,e=y.isAnyDateField(f)||A.isTimeOnlyField(f),l=a.valueExpression||d,n=l&&!d,t=h&&"3d"===h.type;if(this._hasLocalSource||k||g||n)return n||k||g||t?this._summaryStatsFromMemory(a,f):this._summaryStatsFromClientQuery(a,f);if(!this.supportsSQLExpression&&(e||l||"natural-log"===b||"square-root"===b))throw new v(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");
return(b&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):this._summaryStatsFromServiceQuery(a,f)).catch(()=>{x.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,f)})}async uniqueValues(a){const {valueExpression:c,sqlExpression:b,features:d,useFeaturesInView:h,signal:k}=a,g=c&&(!b||!this.supportsSQLExpression),f=this._hasLocalSource||d||h||g,e=a.view,l=e&&"3d"===e.type,n=await m.getDomainsForFields(a,this);return f?g||d||h||l?this._uvFromMemory(a,n):this._uvFromClientQuery(a,
n):this._uvFromServiceQuery(a,n).catch(t=>{x.throwIfAborted(k);return!a.field||a.field2||a.field3||a.filter?t:this._uvFromGenRenderer(a,n[0])}).catch(()=>{x.throwIfAborted(k);return l?this._uvFromMemory(a,n):this._uvFromClientQuery(a,n)})}async histogram(a){const {field:c,normalizationType:b,normalizationField:d,classificationMethod:h,view:k,filter:g,signal:f}=a;var e=c?this.getField(c):null;e=y.isAnyDateField(e)||A.isTimeOnlyField(e);const l=a.valueExpression||a.sqlExpression,n=l&&!a.sqlExpression,
t=this.supportsSQLExpression,p=!h||"equal-interval"===h,u=a.minValue,z=a.maxValue,E=null!=u&&null!=z,B=a.numBins||m.defaultNumBins;if(this._hasLocalSource||a.features||a.useFeaturesInView||n)return this._histogramFromMemory(a);if((l||t)&&p){if(!t&&(l||"natural-log"===b||"square-root"===b))throw new v(`${this.adapterName}:not-supported`,"Layer does not support standardized SQL expression for queries");return this._histogramForExpr(a)}if(e&&p)throw new v(`${this.adapterName}:not-supported`,"Normalization and date field are not allowed when layer does not support standardized SQL expression for queries");
return b||!p?this._binParamsFromGenRend(a).then(r=>{if(!E)return m.getBins(this,r,c,B,k,g,f);if(u>r.max||z<r.min)throw new v(`${this.adapterName}:insufficient-data`,"Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(p)return m.getBins(this,{min:u,max:z,sqlExpr:r.sqlExpr,excludeZerosExpr:r.excludeZerosExpr},c,B,k,g,f);r=m.getFieldExpr({field:c,normalizationType:b,normalizationField:d,normalizationTotal:r.normTotal,layer:this});r=q.getRangeExpr(r,u,
z);return this._binParamsFromGenRend(a,r).then(R=>m.getBins(this,R,c,B,k,g,f))}):this._histogramForField(a)}async classBreaks(a){const c=!1!==a.analyzeData,b=this._hasLocalSource||a.features||a.useFeaturesInView||a.valueExpression||a.filter;return c&&b?this._classBreaksFromMemory(a):(c?this._classBreaksFromGenRend(a):this._classBreaksFromInterpolation(a)).catch(()=>{x.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})}async queryFeatureCount(a){if(this._hasLocalSource)throw new v(`${this.adapterName}:not-supported`,
"Layer does not support count query");const c=this.layer,b=c.createQuery();b.where=q.mergeWhereClauses(b.where,a.whereClause);m.updateQueryWithFeatureFilter(b,a.filter);return c.queryFeatureCount(b,{signal:a.signal})}async generateRenderer(a,c){const b=this.layer;if(this._hasLocalSource||10.1>b.version)throw new v(`${this.adapterName}:not-supported`,"Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)");const d=b.createQuery();a.where=q.mergeWhereClauses(a.where,
d.where);return M.generateRenderer(b.parsedUrl.path,{source:b.dynamicDataSource??void 0,gdbVersion:b.gdbVersion??void 0},a,{signal:c})}async heatmapStatistics(a){const {field:c,fieldOffset:b,view:d,signal:h}=a;return(c&&null==b?this.summaryStatistics({field:c,view:d,signal:h}):Promise.resolve(null)).then(k=>{let g=b||0;if(k){const {count:f,min:e,max:l}=k;f?e===l&&0===e?g=1:0>=l?g="abs":0>e&&(g=-1.01*e):g=1}return this._heatmapStatsFromMemory(a,g).then(f=>({...f,summaryStatistics:k,fieldOffset:g}))})}async predominantCategories(a){if(!this._hasLocalSource&&
!this.supportsSQLExpression)throw new v(`${this.adapterName}:not-supported`,"Layer does not support advanced SQL expressions and standardized queries");const {fields:c,view:b,signal:d}=a;a=H.getArcadeForPredominantCategory(c);const h=H.getSQLForPredominantCategoryName(c);a=b&&this._hasLocalSource?await this._uvFromMemory({valueExpression:a,view:b,signal:d}):await this._uvFromServiceQuery({sqlExpression:h.expression,valueExpression:a,signal:d});return m.getPredominantCategoriesFromUVInfos(a.uniqueValueInfos,
c)}async getSampleFeatures(a,c){const {view:b,sampleSize:d,requiredFields:h,returnGeometry:k,filter:g,signal:f}=a,e=this.layer.createQuery(),l="json"===c;e.outSpatialReference=a.spatialReference||b?.spatialReference;e.returnGeometry=!!k;e.outFields=h;m.updateQueryWithFeatureFilter(e,g);let n=[],t=!1;if(b)try{const p=await b.whenLayerView(this.layer);if(t=!m.getMissingFields(this,h,p).length)if(n=await this._fetchFeaturesFromMemory(p,e,f,c),n.length&&null!=d&&0<d&&d<=n.length)return G.pickRandom(n,
d,1)}catch(p){x.throwIfAborted(f)}try{if(this._hasLocalSource)return t?n:l?this._fetchFeaturesJSONFromService(e,f):this._fetchFeaturesFromService(e,f);const p=await this.queryFeatureCount({view:b,filter:g,signal:f}),u=this.layer.capabilities.query.maxRecordCount;c=-1===d?p:d;c=u&&c>u?u:c;if(p<=n.length||n.length>=u)return n;I.assertIsSome(b,"FeatureLayerAdapter: must have a view");const z=b.extent.width/b.width/b.scale*4E5;e.maxAllowableOffset=a.resolution||z;if(p<=c)return l?this._fetchFeaturesJSONFromService(e,
f):this._fetchFeaturesFromService(e,f);if(2E4>=p){const E=this.layer.createQuery();m.updateQueryWithFeatureFilter(E,g);const B=await this.layer.queryObjectIds();e.objectIds=G.pickRandom(B,c,1);return l?this._fetchFeaturesJSONFromService(e,f):this._fetchFeaturesFromService(e,f)}this.layer.capabilities?.query?.supportsPagination&&(e.num=Math.min(c,2E4));return l?this._fetchFeaturesJSONFromService(e,f):this._fetchFeaturesFromService(e,f)}catch(p){return x.throwIfAborted(f),n}}load(a){const c=this.layer.load(a).then(async b=>
{this.geometryType=b.geometryType;this.objectIdField=b.objectIdField;this.supportsSQLExpression=b.capabilities?.query?.supportsSqlExpression;this.hasQueryEngine=this._hasLocalSource=!b.url&&!!b.source;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent;this.workerClient=P.WorkerClient.getInstance();await this.workerClient.open(a.signal)});this.addResolvingPromise(c);return Promise.resolve(this)}};F.__decorate([J.property({constructOnly:!0})],C.prototype,"layer",void 0);
return C=F.__decorate([K.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],C)});