// All material copyright Esri, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.28/esri/copyright.txt for details.
//>>built
define("exports ../../../core/Error ../../../core/Logger ../../../core/promiseUtils ../../../chunks/mat3 ../../../geometry/Point ../../../geometry/projection ../../../geometry/support/webMercatorUtils ../../ElevationLayer ../core/ElevationSourceDefinitions ./utils".split(" "),function(B,N,I,O,P,v,J,C,Q,E,z){async function F(e,a,g=!1){if(g)return e;const {feature:{attributes:{cameraOrientation:k,elevationSource:p,cameraHeight:c,location:b}}}=a;return p&&(E.isConstantElevation(p)||p.url?.length)?K(e,
a):G(e,k&&"number"==typeof b.z?b.z-c:0)}async function K(e,a){const {feature:g,options:k,currentCoveragePolygon:p}=a;var c=g.attributes.elevationSource;if(!c)return e;if(E.isConstantElevation(c))return{constantElevation:a}=c,"number"!==typeof a?e:G(e,a);({url:a}=c);if(!a)return e;var {elevationSample:b}=g;if(!b){b="esri.Graphic"===p?.declaredClass?p.geometry?.extent:p.extent;if(!b)return e;b=b.clone();b.xmin/=2;b.xmax*=2;b.ymin/=2;b.ymax*=2;const {error:w,isSupported:t}=await E.validateElevationSourceURL(a);
if(!t){I.getLogger(c).warn(w);const {location:q,cameraHeight:l,cameraOrientation:u}=g.attributes;return G(e,u&&"number"==typeof q.z?q.z-l:0)}c=new Q(a);let r=e;try{await c.load(),g.elevationSample=await c.createElevationSampler(b,k),r=e.map(L(g.elevationSample))}catch(q){O.isAbortError(q)||I.getLogger("esri.layers.orientedImagery.transformations.groundToImageUtils").warn(`#updateElevation() failed to update elevation using the provided elevation source URL: ${a}. Please provide a valid elevation source url.`,
q)}finally{c.destroy()}return r}return e.map(L(b))}function L(e){return a=>{a.z=1;const g=e.queryElevation(J.project(a,e.spatialReference));g?.z&&(a.z=g.z);return a}}function G(e,a){return e.map(g=>{g.z=a;return g})}function R(e,a){const {feature:g,imageProperties:k}=a,{width:p,height:c}=k,{attributes:b}=g;a=z.calculateRotationMatrix("HPR",[b.cameraHeading,b.cameraPitch,b.cameraRoll]);const w=Math.sin(b.imageRotation??0*D),t=Math.cos(b.imageRotation??0*D),r=p??1,q=c??1,l=[Math.abs(t*r+w*q),Math.abs(t*
q-w*r)],u=[-(1/(2*Math.tan(b.horizontalFieldOfView*D/2))),0,.5,0,1/(2*Math.tan(b.verticalFieldOfView*D/2)),.5,0,0,1];let d=new v(b.geometry);d.spatialReference.isWGS84&&4!==b.cameraOrientation?.type&&(d=C.geographicToWebMercator(d));const m=d.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*d.y/6378137))):1,f=P.mul(Array(9),a,u);return e.map(h=>{var n=new v(h);n.spatialReference.isWGS84&&(4===b.cameraOrientation?.type?(h=b.cameraOrientation,n=new v(z.geographicToLTP(n,[h.latitude,
h.longitude,h.ellipsoidRadius,h.squaredEccentricity]))):n=new v(C.geographicToWebMercator(n)));h=(n.z??0)-(d.z??0);const x=(n.x-d.x)/m,y=(n.y-d.y)/m;n=(f[0]*x+f[1]*y+f[2]*h)/(f[6]*x+f[7]*y+f[8]*h)*l[0];h=(f[3]*x+f[4]*y+f[5]*h)/(f[6]*x+f[7]*y+f[8]*h)*l[1];return{x:t*(n-l[0]/2)+w*(h-l[1]/2)+r/2,y:-w*(n-l[0]/2)+t*(h-l[1]/2)+q/2}})}function S(e,a){({feature:a}=a);const {attributes:g}=a;a=g.cameraOrientation;if(!a)throw new N("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");
let k=new v(g.location);k.spatialReference.isWGS84&&4!==g.cameraOrientation?.type&&(k=C.geographicToWebMercator(k));const p=k.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*k.y/6378137))):1;let c;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===a.declaredClass){const {omega:l,phi:u,kappa:d}=a;c=z.calculateRotationMatrix("OPK",[l,u,d])}else{const {cameraHeading:l,cameraPitch:u,cameraRoll:d}=g;c=z.calculateRotationMatrix("HPR",[l,u,d])}const {principalOffsetPoint:b,
focalLength:w,radialDistortionCoefficients:t,affineTransformations:r,tangentialDistortionCoefficients:q}=a;return Promise.all(e.map(l=>{function u(d){if(d.spatialReference.isWGS84)if(4===g.cameraOrientation?.type){var m=g.cameraOrientation;d=new v(z.geographicToLTP(d,[m.latitude,m.longitude,m.ellipsoidRadius,m.squaredEccentricity]))}else d=new v(C.geographicToWebMercator(d));m=(d.z??0)-(k.z??0);var f=(d.x-k.x)/p,h=(d.y-k.y)/p;d=(c[0]*f+c[1]*h+c[2]*m)/(c[6]*f+c[7]*h+c[8]*m);m=(c[3]*f+c[4]*h+c[5]*m)/
(c[6]*f+c[7]*h+c[8]*m);f=d**2+m**2;var n=0;let x=0,y=0,H=h=0;var A=0;let M=0;t&&(n=t[0]??0,x=t[1]??0,y=t[2]??0);q&&(h=q[0],H=q[1]);b&&(A=b[0]??0,M=b[1]??0);n=1+(n||0)*f+(x||0)*f*f+(y||0)*f*f*f;A=-(w??0)*(d*n+(h||0)*(f+2*d**2)+2*(H||0)*d*m)+A;d=-(w??0)*(m*n+(H||0)*(f+2*m**2)+2*(h||0)*d*m)+M;return{x:Number(r[0])+Number(r[1])*A+Number(r[2])*d,y:Number(r[3])+Number(r[4])*A+Number(r[5])*d}}return l.spatialReference.equals(k.spatialReference)?(l=new v(l),u(l)):(l=J.project(l,k.spatialReference))?u(l):
null}))}const D=Math.PI/180;B.transformPoints=async function(e,a,g=!1){if(!e)return[];e=e.map(c=>"esri.geometry.Point"===c.declaredClass?c:v.fromJSON(c));const {feature:k}=a;var {attributes:p}=k;isNaN(parseFloat(p.elevation))&&(p=await F([k.geometry],a),k.attributes.elevation=p[0].z);return F(e,a,g).then(c=>{{const {attributes:b}=a.feature;c=b.isSpherical||360===b.horizontalFieldOfView?{}:b.cameraOrientation?.isAdvanced?S(c,a):Promise.resolve(R(c,a))}return c})};B.updateElevation=F;B.updateElevationUsingElevationSource=
K;Object.defineProperty(B,Symbol.toStringTag,{value:"Module"})});